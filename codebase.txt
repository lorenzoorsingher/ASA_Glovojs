================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-26T23:43:47.869Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
data/
  action.js
  field.js
  position.js
  tile.js
planner/
  bfs_pddl.js
.gitignore
codebase_updated.txt
dashboard.css
index.js
master_agent.js
master_geneticBrain.js
master_rider.js
multi_dashboard.html
package.json
README.md
server.js
utils.js

================================================================
Repository Files
================================================================

================
File: data/action.js
================
import { Position } from "./position.js";

export const ActionType = Object.freeze({
  MOVE: "🔀 move",
  PICKUP: "🟡 pick_up",
  PUTDOWN: "🟢 put_down",
  WAIT: "wait",
});

/**
 * Represents an action that the agent can take
 *
 * @param {Position} source source position
 * @param {Position} target target position
 * @param {ActionType} type action type
 * @param {Parcel} action_parcel parcel to pick up
 */
export class Action {
  constructor(source, target, type, action_parcel) {
    this.source = source;
    this.target = target;
    this.type = type;
    this.action_parcel = action_parcel;
  }

  /**
   * Returns a sequence of actions given a sequence of positions,
   * the type of action and the eventual parcel to pick up
   *
   * @param {Array} path sequence of positions
   * @param {ActionType} type type of action
   * @param {Map} action_parcel parcel to pick up
   *
   * @returns {Array} sequence of actions
   */
  static pathToAction(path, type, action_parcel) {
    // console.log("path: ", path);
    const actions = [];
    const lastPosition = new Position();

    if (path.length == 1) {
      lastPosition.x = Position.deserialize(path[0]).x;
      lastPosition.y = Position.deserialize(path[0]).y;
    } else {
      for (let i = 0; i < path.length - 1; i++) {
        const current = Position.deserialize(path[i]);
        const next = Position.deserialize(path[i + 1]);
        if (current.x === next.x) {
          if (current.y < next.y) {
            actions.push(new Action(current, next, ActionType.MOVE, null));
          } else {
            actions.push(new Action(current, next, ActionType.MOVE, null));
          }
        } else {
          if (current.x < next.x) {
            actions.push(new Action(current, next, ActionType.MOVE, null));
          } else {
            actions.push(new Action(current, next, ActionType.MOVE, null));
          }
        }
        lastPosition.x = next.x;
        lastPosition.y = next.y;
      }
    }

    if (type === ActionType.PICKUP) {
      actions.push(
        new Action(lastPosition, lastPosition, ActionType.PICKUP, action_parcel)
      );
    } else if (type === ActionType.PUTDOWN) {
      actions.push(
        new Action(lastPosition, lastPosition, ActionType.PUTDOWN, null)
      );
    } else {
      actions.push(
        new Action(lastPosition, lastPosition, ActionType.MOVE, null)
      );
    }
    return actions;
  }

  /**
   * Prints the action
   */
  printAction() {
    if (this.action_parcel != null) {
      console.log(
        "\t",
        this.type,
        " from ",
        this.source,
        " to ",
        this.target,
        " -> ",
        this.action_parcel
      );
    } else {
      console.log("\t", this.type, " from ", this.source, " to ", this.target);
    }
  }
}

================
File: data/field.js
================
import { Tile } from "./tile.js";
import { Position, Direction } from "./position.js";
import { sortByKey } from "../utils.js";
import { Beliefset } from "@unitn-asa/pddl-client";
import { bfs_pddl } from "../planner/bfs_pddl.js";
import { USE_PDDL } from "../master_agent.js";

const VERBOSE = false;

/**
 * Represents the game field where the agents move
 * and contains the functions to interact with it
 *
 * @param {number} width width of the field
 * @param {number} height height of the field
 * @param {Array} tiles array of tiles
 *
 * @property {number} width width of the field
 * @property {number} height height of the field
 * @property {Array} field 2D array of tiles
 * @property {Array} parcelSpawners array of spawnable positions
 * @property {Map} paths_cache cache of paths
 * @property {number} cache_hits number of cache hits
 * @property {number} cache_misses number of cache misses
 * @property {number} hit_rate cache hit rate
 */
export class Field {

  constructor(usePddl = false) {
    this.USE_PDDL = usePddl;
    this.beliefSet = new Beliefset();
    // ... rest of the constructor remains the same ...
  }

  init(width, height, tiles) {
    this.width = width;
    this.height = height;
    this.field = [];
    this.parcelSpawners = [];
    this.paths_cache = new Map();
    this.cache_hits = 0;
    this.cache_misses = 0;
    this.hit_rate = 0;
    this.beliefSet = new Beliefset();

    // Initialize the field
    for (let i = 0; i < height; i++) {
        this.field[i] = [];
        for (let j = 0; j < width; j++) {
            let found = false;
            let delivery = false;
            for (const t of tiles) {
                if (t.x == j && t.y == i) {
                    found = true;
                    delivery = t.delivery;
                    break;
                }
            }
            let pos = new Position(j, i);
            this.field[i][j] = new Tile(pos, found, delivery);
            
            // Add object to beliefSet if the tile is walkable
            if (found) {
                this.beliefSet.addObject(`t_${j}_${i}`);
            }
        }
    }

    // populate the parcel spawners list
    for (const t of tiles) {
      if (t.parcelSpawner) {
        this.parcelSpawners.push(new Position(t.x, t.y));
      }
    }

    // Initialize objects in the beliefSet
    for (let i = 0; i < this.height; i++) {
      for (let j = 0; j < this.width; j++) {
          if (this.field[i][j].walkable) {
              this.beliefSet.addObject(`t_${j}_${i}`);
          }
      }
  }

    // //load neighbors
    // for (let i = 0; i < this.height; i++) {
    //   for (let j = 0; j < this.width; j++) {
    //     if (this.field[i][j].walkable) {
    //       this.field[i][j].setNeighbors(this.neighbors(new Position(j, i)));
    //       let neighbors = this.neighbors(new Position(j, i));
    //       for (let neighbor of neighbors) {
    //         this.beliefSet.declare(`connected t_${j}_${i} t_${neighbor.x}_${neighbor.y}`);
    //       }
    //     }
    //   }
    // }

        // Populate the beliefSet with connected predicates
        for (let i = 0; i < this.height; i++) {
          for (let j = 0; j < this.width; j++) {
              if (this.field[i][j].walkable) {
                  let neighbors = this.neighbors(new Position(j, i));
                  for (let neighbor of neighbors) {
                      this.beliefSet.declare(`connected t_${j}_${i} t_${neighbor.x}_${neighbor.y}`);
                  }
              }
          }
      }   

    //load delivery zones
    this.deliveryZones = this.getDeliveryZones();
  }

  /**
   * Returns a synthetic representation of the map
   * used by the dashboard
   *
   * @returns {Array} array of the tiles
   */
  getMap() {
    let tiles = [];
    for (let i = 0; i < this.height; i++) {
      tiles[i] = [];
      for (let j = 0; j < this.width; j++) {
        let cell = { type: "X", parcel: -1 };
        if (this.field[i][j].walkable) {
          cell["type"] = "W";
        }
        if (this.field[i][j].delivery) {
          cell["type"] = "D";
        }
        tiles[i][j] = cell;
      }
    }

    return tiles;
  }

  /**
   * Returns the tile at a given position
   *
   * @param {Position} pos position of the tile
   *
   * @returns {Tile} tile at the given position
   */
  getTile(pos) {
    if (pos.x < 0 || pos.x >= this.width || pos.y < 0 || pos.y >= this.height) {
      console.log("Tile out of bounds");
      return -1;
    }
    let tile = this.field[pos.y][pos.x];
    return tile;
  }

  /**
   * Returns the walkable neighbors of a given position
   *
   * @param {Position} pos position of the tile
   *
   * @returns {Array} array of walkable neighbors
   */
  neighbors(pos) {
    let x = pos.x;
    let y = pos.y;
    const neighbors = [];
    if (x > 0 && this.field[y][x - 1].walkable) {
      neighbors.push({ x: x - 1, y });
      this.beliefSet.declare(`connected t_${x}_${y} t_${x-1}_${y}`);
    }
    if (x < this.width - 1 && this.field[y][x + 1].walkable) {
      neighbors.push({ x: x + 1, y });
      this.beliefSet.declare(`connected t_${x}_${y} t_${x+1}_${y}`);
    }
    if (y > 0 && this.field[y - 1][x].walkable) {
      neighbors.push({ x, y: y - 1 });
      this.beliefSet.declare(`connected t_${x}_${y} t_${x}_${y-1}`);
    }
    if (y < this.height - 1 && this.field[y + 1][x].walkable) {
      neighbors.push({ x, y: y + 1 });
      this.beliefSet.declare(`connected t_${x}_${y} t_${x}_${y+1}`);
    }
    return neighbors;
  }

  /**
   * Computes the shortest path between two positions using
   * the Breadth First Search algorithm
   *
   * @param {Position} start start position
   * @param {Position} end end position
   * @param {Array} blocking_agents list of blocking agents (tiles to be avoided)
   *
   * @returns {Array} shortest path
   */
  bfs(start, end, blocking_agents) {
    const par = {};
    const queue = [];
    const distance = {};

    const CACHE = true;

    let blocking = [];
    for (const a of blocking_agents.values()) {
      blocking.push(a.x + "-" + a.y);
    }

    // creates a unique cache entry for the combination of start, end and blocking agents
    blocking = blocking.sort();
    let entry = start.id + "_" + end.id + "_" + blocking.join("_");

    // check if the path is already in the cache
    if (CACHE) {
      if (this.paths_cache.has(entry)) {
        this.cache_hits += 1;
        return this.paths_cache.get(entry);
      } else {
        this.cache_misses += 1;
      }
    }

    // check whether the start or end tile is unreachable
    if (
      this.isTileUnreachable(start, blocking) ||
      this.isTileUnreachable(end, blocking)
    ) {
      return -1;
    }

    // BFS
    distance[start.id] = 0;
    queue.push(this.getTile(start.position));
    while (queue.length > 0) {
      const node = queue.shift();
      for (const n of node.getNeighbors()) {
        if (!blocking.includes(n.x + "-" + n.y)) {
          VERBOSE && console.log(node.getNeighbors());
          const n_tile = this.getTile(n);
          if (distance[n_tile.id] == undefined) {
            par[n_tile.id] = node;
            distance[n_tile.id] = distance[node.id] + 1;
            queue.push(n_tile);
          }
        }
      }
    }

    let path = [];
    let currentNode = end.id;
    path.push(end.id);
    while (par[currentNode] !== undefined) {
      path.push(par[currentNode].id);
      currentNode = par[currentNode].id;
    }

    if (path.length <= 1) {
      if (!start.position.equals(end.position)) {
        path = -1;
      }
    }

    // if cache is enabled, store the path in the cache
    if (CACHE) {
      this.paths_cache.set(entry, path);
    }
    return path;
  }


  /**
   * Returns the closest delivery zones to a given position
   *
   * @param {Position} pos starting position
   * @param {Array} blocking_agents list of blocking agents (tiles to be avoided)
   *
   * @returns {Array} array of closest delivery zones
   */
  getClosestDeliveryZones(pos, blocking_agents) {
    const x = pos.x;
    const y = pos.y;

    let closest = [];

    for (let d of this.deliveryZones) {
      const path = this.bfs(
        this.getTile(d),
        this.getTile(pos),
        blocking_agents
      );
      if (path != -1) {
        const distance = path.length - 1;
        closest.push({ x: d.x, y: d.y, distance: distance, path: path });
      }
    }

    closest = sortByKey(closest, "distance");
    // console.log("Blocking: ", blocking_agents);
    // console.log("Closest delivery zones: ", closest);
    return closest;
  }

  /**
   * Returns all delivery zones in the field
   *
   * @returns {Array} array of delivery zones
   */
  getDeliveryZones() {
    const positions = [];
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (this.field[y][x].delivery) {
          positions.push(new Position(x, y));
        }
      }
    }
    return positions;
  }

  /**
   * Returns a random spawnable position
   *
   * @param {Position} player_position position of the player
   * @param {Array} blocking_agents list of blocking agents (tiles to be avoided)
   *
   * @returns {Array} path to the spawnable position
   */
  getRandomSpawnable(player_position, blocking_agents) {
    // console.log("Looking for a SPAWNABLE tile from ", player_position);
    const randomOrder = this.parcelSpawners.sort(() => Math.random() - 0.5);
    for (const spawner of randomOrder) {
      const tile = this.getTile(spawner);
      let path = this.bfs(tile, this.getTile(player_position), blocking_agents);
      if (path != -1) {
        return path;
      }
    }
    return -1;
  }

  /**
   * Checks whether a tile is null, not walkable, under a blocking agent
   * or unreachable from its neighbors
   *
   * @param {Tile} tile tile to be checked
   * @param {Array} blocking list of blocking agents (tiles to be avoided)
   *
   * @returns {boolean} whether the tile is unreachable
   */
  isTileUnreachable(tile, blocking = []) {
    if (blocking.includes(tile.id) && blocking.length > 0) {
      return true;
    }
    if (tile == null) {
      return true;
    }
    if (!tile.walkable) {
      return true;
    }

    for (let n of tile.neighbors) {
      if (this.field[n.y][n.x].walkable) {
        return false;
      }
    }
    return true;
  }

  async bfsWrapper(start, end, blocking_agents) {
    if (this.USE_PDDL) {
        try {
            const path = await bfs_pddl(start, end, blocking_agents);
            if (path === -1) {
                console.log("PDDL-based BFS failed, falling back to standard BFS");
                return this.bfs(start, end, blocking_agents);
            }
            return path;
        } catch (error) {
            console.error("Error in PDDL-based BFS:", error);
            console.log("Falling back to standard BFS");
            return this.bfs(start, end, blocking_agents);
        }
    } else {
        return this.bfs(start, end, blocking_agents);
    }
  }
}

================
File: data/position.js
================
export const Direction = Object.freeze({
  UP: "up",
  DOWN: "down",
  LEFT: "left",
  RIGHT: "right",
  NONE: "none",
});

/**
 * Represents a position in the grid
 *
 * @param {number} x x coordinate
 * @param {number} y y coordinate
 */
export class Position {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  /**
   * Returns the position that results from moving in a given direction
   *
   * @param {Direction} direction direction to move
   *
   * @returns {Position} new position
   */
  moveTo(direction) {
    switch (direction) {
      case Direction.UP:
        return new Position(this.x, this.y + 1);
      case Direction.DOWN:
        return new Position(this.x, this.y - 1);
      case Direction.LEFT:
        return new Position(this.x - 1, this.y);
      case Direction.RIGHT:
        return new Position(this.x + 1, this.y);
      case Direction.NONE:
        return new Position(this.x, this.y);
      default:
        throw new Error(`err: ${direction}`);
    }
  }

  /**
   * Checks if two positions are equal
   *
   * @param {Position} other other position
   *
   * @returns {boolean} true if the positions are equal, false otherwise
   */
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }

  /**
   * Sets the position to the values of another position
   *
   * @param {Position} pos other position
   */
  set(pos) {
    this.x = pos.x;
    this.y = pos.y;
  }

  /**
   * Returns the direction from a source position to a target position
   *
   * @param {Position} source source position
   * @param {Position} target target position
   *
   * @returns {Direction} direction
   */
  static getDirectionTo(source, target) {
    if (source.x < target.x) {
      return Direction.RIGHT;
    } else if (source.x > target.x) {
      return Direction.LEFT;
    } else if (source.y < target.y) {
      return Direction.UP;
    } else if (source.y > target.y) {
      return Direction.DOWN;
    } else {
      return Direction.NONE;
    }
  }

  /**
   * Returns a string representation of a position
   *
   * @param {Position} pos position to serialize
   *
   * @returns {string} string representation of the position
   */
  static serialize(pos) {
    return `${pos.x}-${pos.y}`;
  }

  /**
   * Returns a position from a string
   *
   * @param {string} str string representation of the position
   *
   * @returns {Position} position
   */
  static deserialize(str) {
    const [x, y] = str.split("-");
    return new Position(Number(x), Number(y));
  }
}

================
File: data/tile.js
================
import { Position, Direction } from "./position.js";

/**
 * Represents a tile in the field
 *
 * @param {Position} position position of the tile
 * @param {boolean} walk it's a walkable tile
 * @param {boolean} delivery it's a delivery zone
 *
 * @property {Position} position position of the tile
 * @property {boolean} walkable it's a walkable tile
 * @property {boolean} delivery it's a delivery zone
 * @property {string} id unique identifier
 * @property {Array} neighbors array of reachable neighbors
 *
 */
export class Tile {
  constructor(position, walk, delivery) {
    this.position = position;
    this.walkable = walk;
    this.delivery = delivery;
    this.id = Position.serialize(this.position);
    this.neighbors = [];
  }

  setNeighbors(neigh) {
    this.neighbors = neigh;
  }

  getNeighbors() {
    return this.neighbors;
  }
}

================
File: planner/bfs_pddl.js
================
import { onlineSolver, PddlExecutor, PddlProblem, Beliefset, PddlDomain, PddlAction } from "@unitn-asa/pddl-client";
import { Position } from "../data/position.js";
import { map } from "../master_agent.js";

const PDDL_solver = onlineSolver;

export async function bfs_pddl(start, end, blocking_agents) {
    try {
        // Create a new beliefset for the initial state
        let initialState = new Beliefset();
        initialState.declare(`at t_${start.x}_${start.y}`);
        
        // Add connected predicates from map.beliefSet
        for (let belief of map.beliefSet.entries) {
            if (belief[1] && belief[0].startsWith('connected')) {
                initialState.declare(belief[0]);
            }
        }

        // Add blocking agents as obstacles
        for (let agent of blocking_agents) {
            initialState.declare(`obstacle t_${agent.x}_${agent.y}`);
        }

        // Construct the objective
        let objective_str = `at t_${end.x}_${end.y}`;

        // Create the PDDL problem
        var pddlProblem = new PddlProblem(
            'bfs-problem',
            map.beliefSet.objects.join(' '),
            initialState.toPddlString(),
            objective_str
        );

        // Create the move action
        let move = new PddlAction(
            'move',
            '?from ?to',
            'and (at ?from) (connected ?from ?to) (not (obstacle ?to))',
            'and (not (at ?from)) (at ?to)',
            async (f, t) => {}
        );

        // Create the PDDL domain
        let pddlDomain = new PddlDomain('BFS', move);

        // Solve the PDDL problem
        let problem = pddlProblem.toPddlString();
        let domain = pddlDomain.toPddlString();
        console.log("Domain:", domain);
        console.log("Problem:", problem);
        let pddl = await PDDL_solver(domain, problem);

        // Check if pddl is undefined or empty
        if (!pddl || pddl.length === 0) {
            console.log("No path found by PDDL solver");
            return -1;
        }

        // Extract the path from the PDDL solution
        let path = [];
        for (let action of pddl) {
            if (action.action === 'move') {
                let [_, to] = action.args;
                let [prefix, x, y] = to.split('_');
                path.push(`${x}-${y}`);
            }
        }

        // Add the start position to the beginning of the path
        path.unshift(`${start.x}-${start.y}`);

        return path;
    } catch (error) {
        console.error("Error in bfs_pddl:", error);
        return -1;
    }
}

================
File: .gitignore
================
node_modules

.vscode

================
File: codebase_updated.txt
================
================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-26T21:37:47.038Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
data/
  action.js
  field.js
  position.js
  tile.js
planner/
  bfs_pddl.js
.gitignore
dashboard.css
index.js
master_agent.js
master_geneticBrain.js
master_rider.js
multi_dashboard.html
package.json
README.md
server.js
utils.js

================================================================
Repository Files
================================================================

================
File: data/action.js
================
import { Position } from "./position.js";

export const ActionType = Object.freeze({
  MOVE: "🔀 move",
  PICKUP: "🟡 pick_up",
  PUTDOWN: "🟢 put_down",
  WAIT: "wait",
});

/**
 * Represents an action that the agent can take
 *
 * @param {Position} source source position
 * @param {Position} target target position
 * @param {ActionType} type action type
 * @param {Parcel} action_parcel parcel to pick up
 */
export class Action {
  constructor(source, target, type, action_parcel) {
    this.source = source;
    this.target = target;
    this.type = type;
    this.action_parcel = action_parcel;
  }

  /**
   * Returns a sequence of actions given a sequence of positions,
   * the type of action and the eventual parcel to pick up
   *
   * @param {Array} path sequence of positions
   * @param {ActionType} type type of action
   * @param {Map} action_parcel parcel to pick up
   *
   * @returns {Array} sequence of actions
   */
  static pathToAction(path, type, action_parcel) {
    // console.log("path: ", path);
    const actions = [];
    const lastPosition = new Position();

    if (path.length == 1) {
      lastPosition.x = Position.deserialize(path[0]).x;
      lastPosition.y = Position.deserialize(path[0]).y;
    } else {
      for (let i = 0; i < path.length - 1; i++) {
        const current = Position.deserialize(path[i]);
        const next = Position.deserialize(path[i + 1]);
        if (current.x === next.x) {
          if (current.y < next.y) {
            actions.push(new Action(current, next, ActionType.MOVE, null));
          } else {
            actions.push(new Action(current, next, ActionType.MOVE, null));
          }
        } else {
          if (current.x < next.x) {
            actions.push(new Action(current, next, ActionType.MOVE, null));
          } else {
            actions.push(new Action(current, next, ActionType.MOVE, null));
          }
        }
        lastPosition.x = next.x;
        lastPosition.y = next.y;
      }
    }

    if (type === ActionType.PICKUP) {
      actions.push(
        new Action(lastPosition, lastPosition, ActionType.PICKUP, action_parcel)
      );
    } else if (type === ActionType.PUTDOWN) {
      actions.push(
        new Action(lastPosition, lastPosition, ActionType.PUTDOWN, null)
      );
    } else {
      actions.push(
        new Action(lastPosition, lastPosition, ActionType.MOVE, null)
      );
    }
    return actions;
  }

  /**
   * Prints the action
   */
  printAction() {
    if (this.action_parcel != null) {
      console.log(
        "\t",
        this.type,
        " from ",
        this.source,
        " to ",
        this.target,
        " -> ",
        this.action_parcel
      );
    } else {
      console.log("\t", this.type, " from ", this.source, " to ", this.target);
    }
  }
}

================
File: data/field.js
================
import { Tile } from "./tile.js";
import { Position, Direction } from "./position.js";
import { sortByKey } from "../utils.js";
import { Beliefset } from "@unitn-asa/pddl-client";

const VERBOSE = false;

/**
 * Represents the game field where the agents move
 * and contains the functions to interact with it
 *
 * @param {number} width width of the field
 * @param {number} height height of the field
 * @param {Array} tiles array of tiles
 *
 * @property {number} width width of the field
 * @property {number} height height of the field
 * @property {Array} field 2D array of tiles
 * @property {Array} parcelSpawners array of spawnable positions
 * @property {Map} paths_cache cache of paths
 * @property {number} cache_hits number of cache hits
 * @property {number} cache_misses number of cache misses
 * @property {number} hit_rate cache hit rate
 */
export class Field {
  init(width, height, tiles) {
    this.width = width;
    this.height = height;
    this.field = [];
    this.parcelSpawners = [];
    this.paths_cache = new Map();
    this.cache_hits = 0;
    this.cache_misses = 0;
    this.hit_rate = 0;
    this.beliefSet = new Beliefset();

    // fill the field with tiles
    for (let i = 0; i < height; i++) {
      this.field[i] = [];
      for (let j = 0; j < width; j++) {
        let found = false;
        let delivery = false;
        for (const t of tiles) {
          if (t.x == j && t.y == i) {
            found = true;
            delivery = t.delivery;
            break;
          }
        }
        let pos = new Position(j, i);
        this.field[i][j] = new Tile(pos, found, delivery);
      }
    }

    // populate the parcel spawners list
    for (const t of tiles) {
      if (t.parcelSpawner) {
        this.parcelSpawners.push(new Position(t.x, t.y));
      }
    }

    //load neighbors
    for (let i = 0; i < this.height; i++) {
      for (let j = 0; j < this.width; j++) {
        if (this.field[i][j].walkable) {
          this.field[i][j].setNeighbors(this.neighbors(new Position(j, i)));
        }
      }
    }

    //load delivery zones
    this.deliveryZones = this.getDeliveryZones();
  }

  /**
   * Returns a synthetic representation of the map
   * used by the dashboard
   *
   * @returns {Array} array of the tiles
   */
  getMap() {
    let tiles = [];
    for (let i = 0; i < this.height; i++) {
      tiles[i] = [];
      for (let j = 0; j < this.width; j++) {
        let cell = { type: "X", parcel: -1 };
        if (this.field[i][j].walkable) {
          cell["type"] = "W";
        }
        if (this.field[i][j].delivery) {
          cell["type"] = "D";
        }
        tiles[i][j] = cell;
      }
    }

    return tiles;
  }

  /**
   * Returns the tile at a given position
   *
   * @param {Position} pos position of the tile
   *
   * @returns {Tile} tile at the given position
   */
  getTile(pos) {
    if (pos.x < 0 || pos.x >= this.width || pos.y < 0 || pos.y >= this.height) {
      console.log("Tile out of bounds");
      return -1;
    }
    let tile = this.field[pos.y][pos.x];
    return tile;
  }

  /**
   * Returns the walkable neighbors of a given position
   *
   * @param {Position} pos position of the tile
   *
   * @returns {Array} array of walkable neighbors
   */
  neighbors(pos) {
    let x = pos.x;
    let y = pos.y;
    const neighbors = [];
    if (x > 0 && this.field[y][x - 1].walkable) {
      neighbors.push({ x: x - 1, y });
      this.beliefSet.declare(`connected t_${x}_${y} t_${x-1}_${y}`);
    }
    if (x < this.width - 1 && this.field[y][x + 1].walkable) {
      neighbors.push({ x: x + 1, y });
      this.beliefSet.declare(`connected t_${x}_${y} t_${x+1}_${y}`);
    }
    if (y > 0 && this.field[y - 1][x].walkable) {
      neighbors.push({ x, y: y - 1 });
      this.beliefSet.declare(`connected t_${x}_${y} t_${x}_${y-1}`);
    }
    if (y < this.height - 1 && this.field[y + 1][x].walkable) {
      neighbors.push({ x, y: y + 1 });
      this.beliefSet.declare(`connected t_${x}_${y} t_${x}_${y+1}`);
    }
    return neighbors;
  }

  /**
   * Computes the shortest path between two positions using
   * the Breadth First Search algorithm
   *
   * @param {Position} start start position
   * @param {Position} end end position
   * @param {Array} blocking_agents list of blocking agents (tiles to be avoided)
   *
   * @returns {Array} shortest path
   */
  bfs(start, end, blocking_agents) {
    const par = {};
    const queue = [];
    const distance = {};

    const CACHE = true;

    let blocking = [];
    for (const a of blocking_agents.values()) {
      blocking.push(a.x + "-" + a.y);
    }

    // creates a unique cache entry for the combination of start, end and blocking agents
    blocking = blocking.sort();
    let entry = start.id + "_" + end.id + "_" + blocking.join("_");

    // check if the path is already in the cache
    if (CACHE) {
      if (this.paths_cache.has(entry)) {
        this.cache_hits += 1;
        return this.paths_cache.get(entry);
      } else {
        this.cache_misses += 1;
      }
    }

    // check whether the start or end tile is unreachable
    if (
      this.isTileUnreachable(start, blocking) ||
      this.isTileUnreachable(end, blocking)
    ) {
      return -1;
    }

    // BFS
    distance[start.id] = 0;
    queue.push(this.getTile(start.position));
    while (queue.length > 0) {
      const node = queue.shift();
      for (const n of node.getNeighbors()) {
        if (!blocking.includes(n.x + "-" + n.y)) {
          VERBOSE && console.log(node.getNeighbors());
          const n_tile = this.getTile(n);
          if (distance[n_tile.id] == undefined) {
            par[n_tile.id] = node;
            distance[n_tile.id] = distance[node.id] + 1;
            queue.push(n_tile);
          }
        }
      }
    }

    let path = [];
    let currentNode = end.id;
    path.push(end.id);
    while (par[currentNode] !== undefined) {
      path.push(par[currentNode].id);
      currentNode = par[currentNode].id;
    }

    if (path.length <= 1) {
      if (!start.position.equals(end.position)) {
        path = -1;
      }
    }

    // if cache is enabled, store the path in the cache
    if (CACHE) {
      this.paths_cache.set(entry, path);
    }
    return path;
  }


  /**
   * Returns the closest delivery zones to a given position
   *
   * @param {Position} pos starting position
   * @param {Array} blocking_agents list of blocking agents (tiles to be avoided)
   *
   * @returns {Array} array of closest delivery zones
   */
  getClosestDeliveryZones(pos, blocking_agents) {
    const x = pos.x;
    const y = pos.y;

    let closest = [];

    for (let d of this.deliveryZones) {
      const path = this.bfs(
        this.getTile(d),
        this.getTile(pos),
        blocking_agents
      );
      if (path != -1) {
        const distance = path.length - 1;
        closest.push({ x: d.x, y: d.y, distance: distance, path: path });
      }
    }

    closest = sortByKey(closest, "distance");
    // console.log("Blocking: ", blocking_agents);
    // console.log("Closest delivery zones: ", closest);
    return closest;
  }

  /**
   * Returns all delivery zones in the field
   *
   * @returns {Array} array of delivery zones
   */
  getDeliveryZones() {
    const positions = [];
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        if (this.field[y][x].delivery) {
          positions.push(new Position(x, y));
        }
      }
    }
    return positions;
  }

  /**
   * Returns a random spawnable position
   *
   * @param {Position} player_position position of the player
   * @param {Array} blocking_agents list of blocking agents (tiles to be avoided)
   *
   * @returns {Array} path to the spawnable position
   */
  getRandomSpawnable(player_position, blocking_agents) {
    // console.log("Looking for a SPAWNABLE tile from ", player_position);
    const randomOrder = this.parcelSpawners.sort(() => Math.random() - 0.5);
    for (const spawner of randomOrder) {
      const tile = this.getTile(spawner);
      let path = this.bfs(tile, this.getTile(player_position), blocking_agents);
      if (path != -1) {
        return path;
      }
    }
    return -1;
  }

  /**
   * Checks whether a tile is null, not walkable, under a blocking agent
   * or unreachable from its neighbors
   *
   * @param {Tile} tile tile to be checked
   * @param {Array} blocking list of blocking agents (tiles to be avoided)
   *
   * @returns {boolean} whether the tile is unreachable
   */
  isTileUnreachable(tile, blocking = []) {
    if (blocking.includes(tile.id) && blocking.length > 0) {
      return true;
    }
    if (tile == null) {
      return true;
    }
    if (!tile.walkable) {
      return true;
    }

    for (let n of tile.neighbors) {
      if (this.field[n.y][n.x].walkable) {
        return false;
      }
    }
    return true;
  }
}

================
File: data/position.js
================
export const Direction = Object.freeze({
  UP: "up",
  DOWN: "down",
  LEFT: "left",
  RIGHT: "right",
  NONE: "none",
});

/**
 * Represents a position in the grid
 *
 * @param {number} x x coordinate
 * @param {number} y y coordinate
 */
export class Position {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  /**
   * Returns the position that results from moving in a given direction
   *
   * @param {Direction} direction direction to move
   *
   * @returns {Position} new position
   */
  moveTo(direction) {
    switch (direction) {
      case Direction.UP:
        return new Position(this.x, this.y + 1);
      case Direction.DOWN:
        return new Position(this.x, this.y - 1);
      case Direction.LEFT:
        return new Position(this.x - 1, this.y);
      case Direction.RIGHT:
        return new Position(this.x + 1, this.y);
      case Direction.NONE:
        return new Position(this.x, this.y);
      default:
        throw new Error(`err: ${direction}`);
    }
  }

  /**
   * Checks if two positions are equal
   *
   * @param {Position} other other position
   *
   * @returns {boolean} true if the positions are equal, false otherwise
   */
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }

  /**
   * Sets the position to the values of another position
   *
   * @param {Position} pos other position
   */
  set(pos) {
    this.x = pos.x;
    this.y = pos.y;
  }

  /**
   * Returns the direction from a source position to a target position
   *
   * @param {Position} source source position
   * @param {Position} target target position
   *
   * @returns {Direction} direction
   */
  static getDirectionTo(source, target) {
    if (source.x < target.x) {
      return Direction.RIGHT;
    } else if (source.x > target.x) {
      return Direction.LEFT;
    } else if (source.y < target.y) {
      return Direction.UP;
    } else if (source.y > target.y) {
      return Direction.DOWN;
    } else {
      return Direction.NONE;
    }
  }

  /**
   * Returns a string representation of a position
   *
   * @param {Position} pos position to serialize
   *
   * @returns {string} string representation of the position
   */
  static serialize(pos) {
    return `${pos.x}-${pos.y}`;
  }

  /**
   * Returns a position from a string
   *
   * @param {string} str string representation of the position
   *
   * @returns {Position} position
   */
  static deserialize(str) {
    const [x, y] = str.split("-");
    return new Position(Number(x), Number(y));
  }
}

================
File: data/tile.js
================
import { Position, Direction } from "./position.js";

/**
 * Represents a tile in the field
 *
 * @param {Position} position position of the tile
 * @param {boolean} walk it's a walkable tile
 * @param {boolean} delivery it's a delivery zone
 *
 * @property {Position} position position of the tile
 * @property {boolean} walkable it's a walkable tile
 * @property {boolean} delivery it's a delivery zone
 * @property {string} id unique identifier
 * @property {Array} neighbors array of reachable neighbors
 *
 */
export class Tile {
  constructor(position, walk, delivery) {
    this.position = position;
    this.walkable = walk;
    this.delivery = delivery;
    this.id = Position.serialize(this.position);
    this.neighbors = [];
  }

  setNeighbors(neigh) {
    this.neighbors = neigh;
  }

  getNeighbors() {
    return this.neighbors;
  }
}

================
File: planner/bfs_pddl.js
================
import {onlineSolver, PddlExecutor, PddlProblem, Beliefset, PddlDomain, PddlAction} from "@unitn-asa/pddl-client";
import {agentsBeliefSet } from "../master_agent.js";
import { map } from "../master_agent.js";
const PDDL_solver = onlineSolver;

/**
   * Computes the shortest path between two positions using
   * the Breadth First Search algorithm
   *
   * @param {Position} start start position
   * @param {Position} end end position
   * @param {Array} blocking_agents list of blocking agents (tiles to be avoided)
   *
   * @returns {Array} shortest path
   */
export async function bfs_pddl(start, end, blocking_agents) {

    // Construct the beliefset for my starting position
    let position_belief = new Beliefset();
    position_belief.declare('at t_' + start.x + '_' + start.y);
    position_belief.declare('visited t_' + start.x + '_' + start.y);
    
    // Initialize the beliefset so that I begin at timestep 0
    let time_belief = new Beliefset();
    time_belief.declare('time T1');
    for (let i = 2; i <= MAX_FUTURE; i++) {
        time_belief.undeclare('time T' + i);
    }

    // Construct the objective, which is to reach any of the goals
    let objective_str = 'or (at t_' + end.x + '_' + end.y + ')';

    var pddlProblem = new PddlProblem(
      'bfs-example-problem',
      map.beliefSet.objects.join(' '),
      map.beliefSet.toPddlString() + ' ' + position_belief.toPddlString(),
      objective_str
  );

  let plan = [{x: start.x, y: end.y, move: "none"}];
    let moves = new PddlAction(
      'move',
      '?from ?to',
      'and (at ?from) (connected ?from ?to) (not (visitated ?to))',
      'and (not (at ?from)) (at ?to) (visitated ?to)',
      async (f, t) => {
        let from = f.split('_');
        let from_x = parseInt(from[1]);
        let from_y = parseInt(from[2]);
        let to = t.split('_');
        let to_x = parseInt(to[1]);
        let to_y = parseInt(to[2]);

        let move = "none";

        if (from_x < to_x) move = "right";
        if (from_x > to_x) move = "left";
        if (from_y < to_y) move = "down";
        if (from_y > to_y) move = "up";

        plan.push({x: to_x, y: to_y, move: move});
      }
    );

    let pddlDomain = new PddlDomain('BFS', move);

    let problem = pddlProblem.toPddlString();
    let domain = pddlDomain.toPddlString();

    let pddl = await PDDL_solver(domain, problem);

    const pddlExecutor = new PddlExecutor(move);
    await pddlExecutor.exec(pddl, true);

    if (lookUp) planLookUp.set(key, JSON.parse(JSON.stringify(plan)));

    return plan;
  }

  async function PDDL_path(start, end, fallback = true) {

    let path = await bfs_pddl(start, end, []);

    if (path.length === 1 && fallback && !end.some(o => start.x === o.x && start.y === o.y)) {
      console.log("PDDL failed, falling back to BFS");
      path = await bfs(start, end, []);
    }

    return path;
  }

export {PDDL_path, bfs_pddl};

================
File: .gitignore
================
node_modules

.vscode

================
File: dashboard.css
================
table {
    width: 90%;
  }
td {
width: 100px;
position: relative;
}

================
File: index.js
================
#!/usr/bin/env node
import { DeliverooApi, timer } from "@unitn-asa/deliveroo-js-client";
import * as pddlClient from "@unitn-asa/pddl-client";

================
File: master_agent.js
================
console.log("Starting...");
import { Field } from "./data/field.js";
import { Position } from "./data/position.js";
import { MyServer } from "./server.js";
import { Action, ActionType } from "./data/action.js";
import { Rider } from "./master_rider.js";
import { Genetic } from "./master_geneticBrain.js";
import { Beliefset } from "@unitn-asa/pddl-client";

import { manhattanDistance, hasCompletedMovement } from "./utils.js";
import { bfs_pddl } from "./planner/bfs_pddl.js";

export const VERBOSE = false;
const LOCAL = true;

let [NRIDERS, POP, GEN, PORT] = process.argv.slice(2);
if (NRIDERS == undefined) {
  NRIDERS = 1;
}
if (POP == undefined) {
  POP = 100;
}
if (GEN == undefined) {
  GEN = 30;
}

if (PORT == undefined) {
  PORT = 3000;
}

console.log("Population: ", POP);
console.log("Generations: ", GEN);

const dashboard = new MyServer(PORT);

let map_init = false;
const map = new Field(); // contains the game map
const parcels = new Map(); // contains all non-carried parcels

let PARCEL_DECAY = 1000;

class Intention {
  goal;
  type;
  pickUp;
  deliver;
  stop;
  reached;
  started;
  planner = { 'pickup': bfs_pddl }
  move;

  constructor(goal, pickUp = false, deliver = false, type, client) {
    this.goal = goal;
    this.pickUp = pickUp;
    this.deliver = deliver;
    this.type = type;
    this.stop = false;
    this.reached = false;
    this.started = false;
    this.move = {

    }
  }
}

// create riders
let riders = [];
let names = ["BLUE", "PINK", "GREY", "GREEN", "BLACK", "WHITE"];
for (let i = 0; i < NRIDERS; i++) {
  //let uname = Math.random().toString(36).substring(5) + "_" + pop + "_" + gen;
  let uname = names[i] + "_" + POP + "_" + GEN;
  riders.push(new Rider(uname));
}

//create brain with associated riders
let brain = new Genetic(riders, map, parcels, POP, GEN);
let agentsBeliefSet;
let parcelsBeliefSet;

// set up sensings for all riders
riders.forEach((rider, index) => {
  rider.client.onConfig((config) => {
    rider.setConfig(config);
    brain.setConfig(config);

    if (config.PARCEL_DECADING_INTERVAL == "infinite") {
      PARCEL_DECAY = Infinity;
    } else {
      PARCEL_DECAY = config.PARCEL_DECADING_INTERVAL * 1000;
    }
  });

  // note that this happens before the onYou event
  rider.client.onMap((width, height, tiles) => {
    VERBOSE && console.log("Map received. Initializing...");

    //init map only once
    if (!map_init) {
      map.init(width, height, tiles);
      map_init = true;
    }
    //rider.brain.init(map, parcels, new Position(0, 0), pop, gen);
  });

  rider.client.onYou(({ id, name, x, y, score }) => {
    if (!rider.player_init) {
      rider.init(id, name, new Position(x, y), brain);
      rider.player_init = true;
      rider.trg.set(rider.position);
    }
    rider.updatePosition(x, y);
  });

  parcelsBeliefSet = new Beliefset();

  rider.client.onParcelsSensing(async (perceived_parcels) => {
    let parc_before = Array.from(parcels.keys());

    // if memorized parcels in the sensing range are not present
    // anymore, remove them from the parcels list
    for (const [key, value] of parcels.entries()) {
      let parc_pos = new Position(value.x, value.y);
      let found = false;
      let dist = manhattanDistance(rider.position, parc_pos);

      if (dist < rider.config.PARCELS_OBSERVATION_DISTANCE) {
        for (const p of perceived_parcels) {
          if (p.id == key && p.carriedBy == null) {
            parcelsBeliefSet.declare(`parcel_t${p.x}_${p.y}`);
            found = true;
            break;
          }
        }
        if (!found) {
          parcelsBeliefSet.undeclare(`parcel_t${value.x}_${value.y}`);
          parcels.delete(key);
        }
      }
    }

    // update and add free parcels and
    // update rider parcels and carried value
    let carried_parcels = new Map();
    let carrying = 0;
    for (const p of perceived_parcels) {
      if (p.carriedBy == null) {
        parcels.set(p.id, p);
      } else if (p.carriedBy == rider.id) {
        carried_parcels.set(p.id, p.reward);
        carrying += p.reward;
      }
    }

    // if rider is in the process of putting down and the
    // sensing reveals that the rider is not carrying any parcels,
    // confirm delivery and ask for new plan. Otherwise, update carrying value
    if (rider.putting_down) {
      if (carrying <= 0) {
        rider.carrying = 0;
        rider.player_parcels.clear();

        rider.log("Delivered, asking for new plan");
        brain.plan_fit = 0;
        brain.newPlan();
        rider.putting_down = false;
      }
    } else {
      rider.carrying = carrying;
      rider.player_parcels = carried_parcels;
    }

    let parc_after = Array.from(parcels.keys());

    // if parcels have changed during the sensing, recalculate plan
    let changed = JSON.stringify(parc_before) != JSON.stringify(parc_after);
    if (changed) {
      console.log("Parcels changed. Recalculating plan");
      brain.newPlan();
    }
  });

  agentsBeliefSet = new Beliefset();

  rider.client.onAgentsSensing(async (perceived_agents) => {
    // if other agents are within BLOCKING_DISTANCE blocks
    // of the rider, add them to its blocking_agents list

    // reset blocking agents every time the sensing is updated
    rider.blocking_agents.clear();
    // clear belief set
    // for (const a of perceived_agents) {
    //   agentsBeliefSet.undeclare(`agent_t${a.x}_${a.y}`);
    // }
    // Undeclare all agents currently stored in the belief set
    agentsBeliefSet.objects.forEach((obj) => {
      agentsBeliefSet.undeclare(obj);
    });


    let BLOCKING_DISTANCE = 100;
    for (const a of perceived_agents) {
      if (a.name != "god") {
        if (manhattanDistance(rider.position, a) < BLOCKING_DISTANCE) {
          rider.blocking_agents.set(a.id, a);
          agentsBeliefSet.declare(`agent_t${a.x}_${a.y}`);
        }
      }
    }
  });
});
  

// PARCELS CLOCK
setInterval(() => {
  riders.forEach((rider) => {
    // reduce reward of parcels that are not in the sensing range
    for (const [key, value] of parcels.entries()) {
      let parc_pos = new Position(value.x, value.y);
      let dist = manhattanDistance(rider.position, parc_pos);
      if (dist >= rider.config.PARCELS_OBSERVATION_DISTANCE) {
        value.reward--;
        if (value.reward <= 0) {
          parcels.delete(key);
        } else {
          parcels.set(key, value);
        }
      }
    }
  });
}, PARCEL_DECAY);

// DASHBOARD UPDATE
setInterval(() => {
  //organize all the logging data to be sent to the dashboard
  let update_map = map.getMap();
  let riders_data = [];

  riders.forEach((rider) => {
    if (rider.player_init) {
      let plan_move = [];
      let plan_pickup = [];
      let plan_drop = [];
      let rider_parcels = [];

      if (rider.plan.length > 0) {
        for (const p of rider.plan) {
          let move_id = Position.serialize(p.source);
          switch (p.type) {
            case ActionType.MOVE:
              plan_move.push(move_id);
              break;
            case ActionType.PICKUP:
              plan_pickup.push(move_id);
              break;
            case ActionType.PUTDOWN:
              plan_drop.push(move_id);
              break;
          }
        }
      }

      if (rider.player_parcels.size > 0) {
        for (const [key, p] of rider.player_parcels.entries()) {
          rider_parcels.push({ key: key, reward: p });
        }
      }

      let blk_agents = [];
      for (const blk of rider.blocking_agents.values()) {
        blk_agents.push(blk.x + "-" + blk.y);
      }

      riders_data.push({
        x: rider.position.x,
        y: rider.position.y,
        plan: [plan_move, plan_pickup, plan_drop],
        parcels: rider_parcels,
        blk_agents: blk_agents,
      });
    }
  });
  let dash_parcels = [];
  for (const [key, p] of parcels.entries()) {
    dash_parcels.push({ x: p.x, y: p.y, reward: p.reward });
  }

  let dash_data = {
    map_size: [map.width, map.height],
    tiles: update_map,
    riders: riders_data,
    parc: dash_parcels,
  };

  dashboard.emitMessage("map", dash_data);
}, 100);

let start = Date.now();

/**
 * Main loop for the agents
 *
 * @param {Rider} rider
 */
async function loop(rider) {
  // main loop
  while (true) {
    // wait for map and player to be loaded
    if (!rider.player_init) {
      await new Promise((res) => setTimeout(res, 300));
      continue;
    }

    // if a plan exists execute, otherwise create a new one
    if (rider.plan.length > 0) {
      // if the agent has completed the movement and brain has completed the plan
      if (hasCompletedMovement(rider.position) && !brain.planLock) {
        // pick action from plan (depending on when planning was started
        // agent might at the first or second step)
        if (rider.position.equals(rider.plan[0].source)) {
          rider.nextAction = rider.plan.shift();
        } else if (rider.plan.length > 1) {
          if (rider.position.equals(rider.plan[1].source)) {
            rider.nextAction = rider.plan.shift();
            rider.nextAction = rider.plan.shift();
          } else {
            rider.log("No match found for next action");
            rider.log(rider.position);
            rider.log(rider.nextAction);
            rider.log(
              "should be ",
              rider.plan[0].source,
              " OR ",
              rider.plan[1].source
            );
          }
        } else {
          rider.log("Agent appears to be stuck on last move");
          rider.log("Retrying last move");
        }

        //update agent position and target
        rider.src.set(rider.nextAction.source);
        rider.trg.set(rider.nextAction.target);
        rider.no_delivery++;

        // extract action information
        let move = Position.getDirectionTo(rider.src, rider.trg);

        // check if the path is blocked
        if (rider.isPathBlocked()) {
          rider.trg.set(rider.position);
          rider.log("Agent in the way. Recalculating plan");
          brain.plan_fit = 0;
          brain.newPlan();
          continue;
        }

        //avoid server spam
        while (Date.now() - start < rider.config.MOVEMENT_DURATION / 2) {
          await new Promise((res) => setImmediate(res));
        }
        start = Date.now();

        //execute action
        switch (rider.nextAction.type) {
          case ActionType.MOVE:
            if (move != "none") {
              await rider.client.move(move);
            }
            break;
          case ActionType.PICKUP:
            await rider.client.pickup();

            try {
              rider.player_parcels.set(
                rider.nextAction.action_parcel,
                parcels.get(rider.nextAction.action_parcel).reward
              );
              parcels.delete(rider.nextAction.action_parcel);
            } catch (error) {
              rider.log(
                "Parcel either expired or was deleted while executing plan."
              );
            }
            rider.log("PICKING UP ", rider.nextAction.action_parcel);
            break;
          case ActionType.PUTDOWN:
            rider.log("PUTTING DOWN");
            await rider.client.putdown();

            if (!rider.putting_down && rider.carrying > 0) {
              rider.putting_down = true;
            }
            break;
        }
      }
    } else {
      if (rider.putting_down) {
        rider.log("Empty plan but waiting for delivery to complete");
      } else {
        if (Date.now() - rider.plan_cooldown > 1000) {
          rider.plan_cooldown = Date.now();
          rider.log("Plan is empty. Recalculating plan");
          brain.plan_fit = 0;
          brain.newPlan();
        }
      }
    }
    await new Promise((res) => setImmediate(res));
  }
}

// start the loop for all riders
for (let i = 0; i < riders.length; i++) {
  loop(riders[i]);
}

export { parcelsBeliefSet, agentsBeliefSet, map }

================
File: master_geneticBrain.js
================
import { Position, Direction } from "./data/position.js";
import { Action, ActionType } from "./data/action.js";
import { Field } from "./data/field.js";
import { Rider } from "./master_rider.js";
import { sortByKey } from "./utils.js";

/**
 * @class Genetic
 *
 * Contains the genetic algorithm for the planning of the agents,
 * it generates a plan for each agent based on the current state of the
 * entire field and the agents. The plan will be an approximation of
 * of a variation of the Travelling Salesman Problem that takes into
 * account the rewards of the parcels and and the cost of reaching them.
 *
 * @property {Array} riders - The list of all the controlled agents
 * @property {number} nriders - The number of controlled agents
 * @property {Object} config - The configuration object received from the server
 * @property {Field} field - The field object containing the map
 * @property {Map} parcels - The map of all the parcels on the field
 * @property {number} pop - The size of the population for the genetic algorithm
 * @property {number} gen - The number of generations for the genetic algorithm
 * @property {number} plan_fit - The fitness of the current plan
 * @property {Boolean} planLock - A flag to prevent multiple plans from being generated
 * @property {number} tot_time - The total time spent generating plans [metrics]
 * @property {number} tot_plans - The total number of plans generated [metrics]
 */
export class Genetic {
  constructor(riders, field, parcels, pop, gen) {
    //riders
    this.riders = riders;
    this.nriders = riders.length;

    //brain settings
    this.field = field;
    this.parcels = parcels;
    this.plan_fit = 0;
    this.planLock = false;
    this.config = {};

    //Genetic params
    this.pop = pop;
    this.gen = gen;

    //metrics
    this.tot_time = 0;
    this.tot_plans = 0;
    this.plan_time_avg = 0;

    console.log("Genetic brain created with ", this.nriders, " riders");
  }

  /**
   *
   * @param {Object} config - The configuration object received from the server
   */
  setConfig(config) {
    this.config = config;
    console.log("Config received: ", this.config);

    let parcel_decay = parseFloat(this.config.PARCEL_DECADING_INTERVAL);
    if (isNaN(parcel_decay)) {
      if (this.config.PARCEL_DECADING_INTERVAL === "infinite") {
        this.config.PARCEL_DECADING_INTERVAL = 10;
      } else {
        this.config.PARCEL_DECADING_INTERVAL = 0;
      }
    } else {
      this.config.PARCEL_DECADING_INTERVAL = parcel_decay;
    }
  }

  /**
   * Translates the parcels on the field into a graph representation
   * that can be used to generate a plan for the agents.
   *
   * @param {Rider} rider - The rider for which the graph is being generated
   *
   * @returns {[Array, Array, Array]} - The costs, paths and prep_parcels of the graph,
   * costs and paths are both 2-dimensional arrays corresponding to the costs
   * and paths between each pair of nodes, prep_parcels corresponds the the nodes of the graph,
   * each element contains the coordinates and reward of the parcel and  costs and paths both to get
   * there form the player position and to get to the closest delivery zone.
   */
  builGraphInOut(rider) {
    let prep_parcels = [];

    // prepare each parcel for the graph
    for (const [key, p] of this.parcels.entries()) {
      // compute the cost and path from the player to the parcel
      let start = this.field.getTile({ x: p.x, y: p.y });
      let end = this.field.getTile({ x: rider.trg.x, y: rider.trg.y });
      let path_from_player = this.field.bfs(start, end, rider.blocking_agents);
      let cost_from_player;
      if (path_from_player == -1) {
        cost_from_player = Infinity;
      } else {
        cost_from_player = path_from_player.length - 1;
      }

      // compute the cost and path from the parcel to the closest delivery zone
      start = { x: p.x, y: p.y };
      let path_to_zone;
      let cost_to_zone;
      let closest = this.field.getClosestDeliveryZones(
        start,
        rider.blocking_agents
      );

      if (closest.length == 0) {
        cost_to_zone = Infinity;
        path_to_zone = -1;
      } else {
        path_to_zone = closest[0].path;
        cost_to_zone = closest[0].distance - 1;
      }

      let inc = cost_from_player;
      let outc = cost_to_zone;

      prep_parcels.push({
        x: p.x,
        y: p.y,
        rew: p.reward,
        in_c: inc,
        out_c: outc,
        id: key,
        path_in: path_from_player,
        path_out: path_to_zone,
      });
    }

    // build graph matrices
    let costs = [];
    let paths = [];
    for (let i = 0; i < prep_parcels.length; i++) {
      costs[i] = [];
      paths[i] = [];

      for (let j = 0; j < prep_parcels.length; j++) {
        if (i == j) {
          costs[i][j] = Infinity;
        } else {
          let stTile = this.field.getTile({
            x: prep_parcels[i].x,
            y: prep_parcels[i].y,
          });

          let endTile = this.field.getTile({
            x: prep_parcels[j].x,
            y: prep_parcels[j].y,
          });

          let path = this.field.bfs(endTile, stTile, rider.blocking_agents);
          if (path.length == 0 || path == -1) {
            costs[i][j] = Infinity;
            paths[i][j] = [];
          } else {
            paths[i][j] = path;
            costs[i][j] = path.length;
          }
        }
      }
    }

    //this.printMat(costs);
    return [costs, paths, prep_parcels];
  }

  /**
   * Removes a random number of elements from a list
   *
   * @param {Array} list - The list to be masked
   * @returns {Array} - The masked list
   */
  maskList(list) {
    let num_del = list.length - (Math.floor(Math.random() * list.length) + 1);

    for (let i = 0; i < num_del; i++) {
      let idx = Math.floor(Math.random() * list.length);
      list.splice(idx, 1);
    }
    return list;
  }

  /**
   * Generates the scores and chances for the roulette wheel selection
   * of the genetic algorithm
   *
   * @param {Array} population - The population of the genetic algorithm
   * @param {Array} riders_graphs - The paths of the riders
   *
   * @returns {[Array, Array]} - The scores and chances (to be picked) of the population
   */
  rouletteWheel(population, riders_graphs) {
    let scores = [];
    let tot_fit = 0;
    let min_fit = 0;
    for (const family of population) {
      let [fit, _] = this.fitness(family, riders_graphs);
      if (fit < 0) {
        fit = 0;
      }
      scores.push(fit);
      if (fit < min_fit) {
        min_fit = fit;
      }
    }

    for (const score of scores) {
      tot_fit += score - min_fit;
    }

    let chances = [];
    for (const score of scores) {
      let chance = ((score - min_fit) / (tot_fit + 1)) * scores.length;
      chances.push(chance);
    }

    return [scores, chances];
  }

  /**
   * Returns the elite individuals, the
   * best 'elite_rate %' of the population
   *
   * @param {Array} population - The population of the genetic algorithm
   * @param {Array} scores - The scores of the population
   * @param {number} elite_rate - The percentage of the population to be considered elite
   *
   * @returns {Array} - The elite individuals
   */
  getElites(population, scores, elite_rate) {
    let mapped = scores.map((el, idx) => {
      return { index: idx, score: el };
    });

    mapped = sortByKey(mapped, "score");

    let elites = [];
    let num_elites = Math.round(mapped.length * elite_rate);
    for (let i = 0; i < num_elites; i++) {
      elites.push(mapped[mapped.length - i - 1].index);
    }

    let elite_dna = [];
    for (const idx of elites) {
      elite_dna.push(population[idx]);
    }
    return elite_dna;
  }

  /**
   * Picks an individual from the population based on the chances
   * computed by the roulette wheel selection
   *
   * @param {Array} population - The population of the genetic algorithm
   * @param {Array} chances - The chances of each individual to be picked
   *
   * @returns {Array} - The picked individual
   */
  pickOne(population, chances) {
    let val = Math.random();
    let cum = 0;
    let norm = [];

    for (const chance of chances) {
      cum += chance;
    }
    for (const chance of chances) {
      norm.push(chance / cum);
    }
    let idx = 0;
    while (val > 0) {
      val -= norm[idx];
      idx++;
    }
    idx--;

    return population[idx];
  }
  /**
   * Performs a multi-crossover between two parents, each parent
   * is composed of a list of DNAs (one for each rider) where the DNA
   * corresponds to the sequence of parcels to be picked up.
   * Each DNA will be crossed with the corresponding DNA of the other parent
   * and duplicate parcels will be removed starting from the longest sequence.
   *
   * @param {Array} parentA - The first parent
   * @param {Array} parentB - The second parent
   *
   * @returns {Array} - The crossed children
   */
  multiCrossover(parentA, parentB) {
    let childs = [];

    // perform crossover for each rider.
    // Each DNA is split in half and child is composed of the head of
    // one parent and the tail of the other parent. Elements are added
    // one by one making sure that no duplicates are present.
    for (let r = 0; r < this.nriders; r++) {
      let dnaA = parentA[r];
      let dnaB = parentB[r];

      let seg_len = Math.floor(dnaA.length / 2);

      let start = Math.floor((dnaA.length - seg_len) / 2);
      let end = start + seg_len;

      let a_segment = dnaA.slice(start, end);
      let head = [];
      let tail = [];

      for (const el of dnaB) {
        if (!a_segment.includes(el)) {
          if (head.length <= dnaA.length - seg_len) {
            head.push(el);
          } else if (head.length + tail.length < dnaA.length - seg_len) {
            tail.push(el);
          } else {
            break;
          }
        }
      }
      let child = [].concat(head).concat(a_segment).concat(tail);
      childs.push(child);
    }

    // creates a list of tuples containing the length of each DNA
    let subl_len = [];
    for (let i = 0; i < childs.length; i++) {
      subl_len.push({ len: childs[i].length, idx: i });
    }
    subl_len = sortByKey(subl_len, "len");

    // removes duplicate parcels from the childs starting from the longest
    let clean_childs = [];
    let dupl = new Set();
    for (const sub of subl_len) {
      let clean_child = [];
      let idx = sub.idx;
      for (const el of childs[idx]) {
        if (dupl.has(el)) {
        } else {
          clean_child.push(el);
          dupl.add(el);
        }
      }
      clean_childs.push(clean_child);
    }

    // orders the childs based on the original order
    let ordered_childs = [];
    for (let i = 0; i < clean_childs.length; i++) {
      ordered_childs[subl_len[i].idx] = clean_childs[i];
    }

    return ordered_childs;
  }

  /**
   * Computes the cost of a step (going from one node to the next)
   * based on the cost of reaching the node and the current
   * carrying capacity of the agent. The penalty is dinamically
   * computed based on the number of parcels the agent is carrying and
   * the decay of the parcels.
   *
   * @param {number} cost_in - The cost of reaching the parcel
   * @param {number} curr_carr - The current carrying capacity of the agent
   *
   * @returns {number} - The cost of the step
   */
  getStepCost(cost_in, curr_carr) {
    let decay_bonus = (this.config.PARCEL_DECADING_INTERVAL - 1) / 9;

    let STEP_COST = 0.5 - decay_bonus * 0.2;

    let cost = cost_in * STEP_COST * (curr_carr + 1);
    return cost;
  }

  /**
   * Computes the fitness of a family (a list of DNAs, one for each rider)
   * based on the paths of the riders and the delivery-only fits.
   *
   * The fitness is computed for plans containing parcels so delivery-only
   * plans are computed separately once and considered only if they are better
   * than all the other plans.
   *
   * @param {Array} family - The family of DNAs
   * @param {Array} riders_graphs - The graphs for each rider
   * @param {Array} delivery_only_fits - The delivery-only fits
   *
   * @returns {[Number, Array]} - The cumulative reward of the family and a list
   * of booleans indicating if that rider should deliver only
   */
  fitness(family, riders_graphs, delivery_only_fits = null) {
    let cumulative_rew = 0;
    let delivery_only = [];

    for (let r = 0; r < this.nriders; r++) {
      let delivery_only_fit = -Infinity;
      if (delivery_only_fits != null) {
        delivery_only_fit = delivery_only_fits[r];
      }

      let costs = riders_graphs[r].costs;
      let nodes = riders_graphs[r].nodes;
      let dna = family[r];
      let rew = 0;

      if (dna.length > 0) {
        let curr_carr = this.riders[r].player_parcels.size;

        // reward for the amount of points the rider is already carrying
        rew = this.riders[r].carrying;

        // reward of first parcel minus cost of reaching it
        rew +=
          nodes[dna[0]].rew - this.getStepCost(nodes[dna[0]].in_c, curr_carr);

        curr_carr += 1;

        // reward of each parcel in DNA minus cost of reaching it
        for (let i = 1; i < dna.length; i++) {
          rew +=
            nodes[dna[i]].rew -
            this.getStepCost(costs[dna[i - 1]][dna[i]], curr_carr);

          curr_carr += 1;
        }

        // cost of reaching the delivery zone fron the last parcel
        rew += -this.getStepCost(nodes[dna[dna.length - 1]].out_c, curr_carr); //* STEP_COST * curr_carr;
      } else {
        rew = 0;
      }

      // check if it's better to deliver only
      if (rew < delivery_only_fit && delivery_only_fit > 0) {
        cumulative_rew += delivery_only_fit;
        delivery_only.push(true);
      } else {
        cumulative_rew += rew;
        delivery_only.push(false);
      }
    }
    return [cumulative_rew, delivery_only];
  }

  /**
   * Generates a plan for the agents based on the genetic algorithm.
   * The script will create a starting random population of size 'pop_size'
   * and iterate for 'gen_num' generations. Each new generation will be
   * composed of the 'elite_rate'% of the best individuals of the previous
   * generation and the rest will be generated by crossover and mutation.
   *
   * @param {Array} riders_graphs - The graphs for each rider
   * @param {Array} delivery_only_fits - The delivery-only fits
   * @param {number} pop_size - The size of the population
   * @param {number} gen_num - The number of generations
   * @param {number} mutation_rate - The mutation rate
   * @param {number} elite_rate - The elite rate
   *
   * @returns {[Array, Number]} - The generated plan and its fitness
   */
  geneticTSP(
    riders_graphs,
    delivery_only_fits,
    pop_size = 1000,
    gen_num = 100,
    mutation_rate = 0.1,
    elite_rate = 0.5
  ) {
    let genes = [];

    // prepare the genes for the genetic algorithm
    for (let rid = 0; rid < this.nriders; rid++) {
      const r = riders_graphs[rid];

      genes = Array.from(Array(r.nodes.length).keys());

      if (genes.length == 0) {
        let empty_plan = Array.from({ length: this.riders.length }, () => []);
        console.log("No parcels in sight, returning empty plan ", empty_plan);
        return [empty_plan, 0];
      }
    }

    let best_d_o = [];
    let best_dna = [];
    let best_fit = 0;
    let population = [];

    // generate the initial population
    for (let i = 0; i < pop_size; i++) {
      let order = genes.slice();
      order = order.sort(() => Math.random() - 0.5);
      let masked = this.maskList(order);

      let slices = [];
      for (let j = 0; j < this.nriders - 1; j++) {
        slices.push(Math.round(Math.random() * (masked.length - 1)));
      }
      slices = slices.sort((a, b) => a - b);

      let family = [];

      family.push(masked.slice(0, slices[0]));
      for (let j = 1; j < slices.length; j++) {
        family.push(masked.slice(slices[j - 1], slices[j]));
      }
      if (slices.length > 0) {
        family.push(masked.slice(slices[slices.length - 1], masked.length));
      }

      population.push(family);
    }

    // iterate over the generations
    for (let i = 0; i < gen_num; i++) {
      let new_pop = [];

      //compute chance of each individual to be picked
      const [scores, chances] = this.rouletteWheel(population, riders_graphs);

      // get the elite (best) individuals
      let elites = this.getElites(population, scores, elite_rate);
      new_pop = new_pop.concat(elites);

      // generate the new population
      for (let j = 0; j < pop_size - elites.length; j += 2) {
        let parentA = this.pickOne(population, chances);
        let parentB = this.pickOne(population, chances);

        let childA = this.multiCrossover(parentA, parentB);
        let childB = this.multiCrossover(parentB, parentA);

        new_pop.push(childA);
        new_pop.push(childB);
      }

      // mutate the population
      for (let j = 0; j < new_pop.length; j++) {
        if (Math.random() < mutation_rate) {
          let idxFamA = Math.floor(Math.random() * new_pop[j].length);
          let idxFamB = Math.floor(Math.random() * new_pop[j].length);

          let idxA = Math.floor(Math.random() * new_pop[j][idxFamA].length);
          let idxB = Math.floor(Math.random() * new_pop[j][idxFamB].length);

          // adding padding to avoid indexing empty arrays
          for (let k = 0; k < new_pop[j].length; k++) {
            new_pop[j][k].push(-1);
          }

          let tmp = new_pop[j][idxFamA][idxA];
          new_pop[j][idxFamA][idxA] = new_pop[j][idxFamB][idxB];
          new_pop[j][idxFamB][idxB] = tmp;

          // removing padding
          for (let k = 0; k < new_pop[j].length; k++) {
            new_pop[j][k] = new_pop[j][k].filter((a) => a != -1);
          }
        }
      }

      population = new_pop;

      let tot_fit = 0;

      // saving the best family of the generation
      for (const family of population) {
        let [fit, d_o] = this.fitness(
          family,
          riders_graphs,
          delivery_only_fits
        );
        tot_fit += fit;

        if (fit > best_fit) {
          best_d_o = d_o;
          best_fit = fit;
          best_dna = JSON.parse(JSON.stringify(family));
        }
      }
      // console.log("Best DNA: ", best_dna);
      // if (i % 5 == 0) {
      //   console.log("Gen " + i + " avg fitness: ", tot_fit / pop_size);
      //   //console.log(population.length, " ", pop_size);
      // }
    }

    // if the best fit is 0, return an empty plan
    if (best_fit == 0) {
      let empty_plan = Array.from({ length: this.nriders }, () => []);
      console.log("Best fit is zero, returning empty plan ", empty_plan);
      best_dna = empty_plan;
    }

    // if for any driver it's better to deliver only, set its plan to deliver only
    for (let r = 0; r < this.nriders; r++) {
      if (best_d_o[r]) {
        let d_o_f = delivery_only_fits[r];
        this.riders[r].log("Seems like it's better to deliver only: ", d_o_f);
        console.log(best_d_o);
        best_dna[r] = "D";
      }
    }
    return [best_dna, best_fit];
  }

  /**
   * The function will check if the rider is carrying parcels, if so
   * it will try to generate a plan to deliver them. If no delivery zones
   * are reachable or the rider is not carrying any parcels, the function
   * will generate a plan to move to a random spawnable tile.
   * If these options are not available, the function will return a
   * reflexive move.
   *
   * @param {Rider} rider
   * @returns {Array} - The sequence of actions for the backup plan
   */
  backupPlan(rider) {
    let rew = 1;

    let path_to_closest = -1;
    let path_to_spawnable = -1;

    // if rider is carrying parcels, generate a plan to deliver them
    // otherwise generate a plan to move to a random spawnable tile
    if (rider.carrying > 0) {
      rew += rider.carrying;
      console.log("Agent is packing, going to closest delivery zone");

      let closest = this.field.getClosestDeliveryZones(
        rider.trg,
        rider.blocking_agents
      );

      if (closest.length == 0) {
        rider.log("No delivery zones reachable");
      } else {
        path_to_closest = closest[0].path;
      }
    } else {
      rider.log("No parcels on rider, generating random plan");
      path_to_spawnable = this.field.getRandomSpawnable(
        new Position(rider.trg.x, rider.trg.y),
        rider.blocking_agents
      );
    }

    let actions = [];

    if (path_to_closest != -1) {
      console.log("[BACKUP] A reachable delivery zone was found!");
      actions = Action.pathToAction(path_to_closest, ActionType.PUTDOWN, null);
    } else if (path_to_spawnable != -1) {
      console.log("[BACKUP] A reachable spawnable tile was found!");
      actions = Action.pathToAction(path_to_spawnable, ActionType.MOVE, null);
      rew = 0;
    } else {
      console.log("[BACKUP] No reachable valid plans found!");
      console.log("[BACKUP] Returning random reflexive move");
      rew = 0;
      let blocking = [];
      for (const a of rider.blocking_agents.values()) {
        blocking.push(a.x + "-" + a.y);
      }

      let movement = null;
      let target_position = null;
      for (const dir in Direction) {
        target_position = new Position(rider.trg.x, rider.trg.y).moveTo(
          Direction[dir]
        );
        console.log("trying to move ", Direction[dir], " to ", target_position);
        let target_tile = this.field.getTile(target_position);

        if (
          target_tile != -1 &&
          !this.field.isTileUnreachable(target_tile, blocking)
        ) {
          movement = Direction[dir];
          console.log("found walkable tile");
          break;
        } else {
          console.log("Tile is unreachable");
        }
      }

      let starting_action = new Action(
        rider.src,
        rider.trg,
        ActionType.MOVE,
        null
      );
      actions = [
        starting_action,
        new Action(
          new Position(rider.trg.x, rider.trg.y),
          target_position,
          ActionType.MOVE,
          null
        ),
      ];
    }

    console.log("[BRAIN] Generated BACKUP plan with rew ", rew);
    return [actions, rew];
  }

  /**
   * Generates a plan for the agents based on the genetic algorithm.
   * The genetic algorithm will return a sequence of parcels to pick up
   * for each rider. This function will call a backup plan in case the
   * genetic algorithm fails to generate a good (fit > 0) and will
   * check if it's better to deliver only.
   * Based on the generated plan, the function will generate a sequence
   * of actions for each rider.
   *
   * @returns {Array} - The sequence of actions for each rider
   */
  createPlan() {
    let riders_graphs = [];

    // build the parcels graph for each rider with the costs and paths to move
    // from one parcel to another as well as the information (cost to reach, cost to deliver
    // and reward) of each parcel
    console.log("starting positions: ");
    for (const r of this.riders) {
      r.log("Rider at: " + r.trg.x + " " + r.trg.y);
      const [costs, paths, parc] = this.builGraphInOut(r);
      riders_graphs.push({
        costs: costs,
        paths: paths,
        nodes: parc,
      });
    }

    // compute the delivery-only fits for each rider and generate the delivery plans
    // that will be used in case the fitness of the generated plan is lower
    // than the delivery-only plan
    let delivery_only_fits = [];
    let delivery_only_plans = [];
    for (let rid = 0; rid < this.nriders; rid++) {
      let agent = this.riders[rid];
      let closest = this.field.getClosestDeliveryZones(
        agent.trg,
        agent.blocking_agents
      );

      if (closest.length == 0) {
        delivery_only_fits.push(-Infinity);
        delivery_only_plans.push(-1);
      } else {
        let delivery_only_fit =
          agent.carrying -
          this.getStepCost(closest[0].distance, agent.player_parcels.size);

        if (delivery_only_fit <= 0) {
          delivery_only_fits.push(-Infinity);
          delivery_only_plans.push(-1);
        } else {
          delivery_only_fits.push(delivery_only_fit);
          delivery_only_plans.push(
            Action.pathToAction(closest[0].path, ActionType.PUTDOWN, null)
          );
        }
      }
    }
    console.log("delivery_only_fits: ", delivery_only_fits);

    // generate the plan using the genetic algorithm
    const [best_path, best_fit] = this.geneticTSP(
      riders_graphs,
      delivery_only_fits,
      this.pop,
      this.gen,
      0.3,
      0.5,
      0.2
    );

    //TODO:
    let parcels_path = Array.from({ length: this.nriders }, () => []);
    let all_plans = [];

    // generate the sequence of actions for each rider based on the generated plan
    for (let r = 0; r < this.nriders; r++) {
      let plan = [];

      if (best_path[r] == "D") {
        // if plan is to deliver only, assign it
        plan = delivery_only_plans[r];
      } else {
        // if no valid plan was found or fitness is 0 generate a backup plan
        if (best_path[r].length == 0 || best_fit == 0) {
          plan = this.backupPlan(this.riders[r]);

          console.log("[BRAIN] Backup plan generated");
          all_plans.push(plan[0]);
          continue;
        }

        // prepare the list of parcels to be picked up
        for (const idx of best_path[r]) {
          let par = riders_graphs[r].nodes[idx];

          parcels_path[r].push({
            pos: new Position(par.x, par.y),
            parcel: par.id,
            path_in: par.path_in,
            path_out: par.path_out,
            inc: par.in_c,
          });
        }

        let chosen_path = parcels_path[r];

        // insert current rider action as first action in case
        // the rider is not at the starting position yet
        let starting_action = new Action(
          this.riders[r].src,
          this.riders[r].trg,
          ActionType.MOVE,
          null
        );

        plan.push(starting_action);

        // insert actions for reaching the first parcel
        let actions = Action.pathToAction(
          chosen_path[0].path_in,
          ActionType.PICKUP,
          chosen_path[0].parcel
        );
        plan = plan.concat(actions);

        // insert actions for reaching the rest of the parcels
        for (let i = 0; i < best_path[r].length; i++) {
          let curridx = best_path[r][i];
          if (i + 1 < best_path[r].length) {
            let nextidx = best_path[r][i + 1];
            let semi_path = riders_graphs[r].paths[curridx][nextidx];

            actions = Action.pathToAction(
              semi_path,
              ActionType.PICKUP,
              chosen_path[i + 1].parcel
            );

            plan = plan.concat(actions);
          }
        }

        // insert actions for reaching the delivery zone and delivering the parcels
        actions = Action.pathToAction(
          chosen_path[chosen_path.length - 1].path_out,
          ActionType.PUTDOWN,
          null
        );
        plan = plan.concat(actions);

        // it can happen that the rider travels twice on a parcel
        // but the plan says to pickup only on the second pass.
        // This can be fixed by reordering the actions

        // let corr_plan = [];
        // for (let i = 1; i < plan.length; i += 1) {
        //   if (plan[i].type == ActionType.PICKUP) {
        //     for (let j = 1; j < i; j++) {
        //       if (plan[j].type == ActionType.MOVE) {
        //         if (plan[j].source.equals(plan[i].source)) {
        //           // console.log(
        //           //   "###################################################################"
        //           // );
        //           // console.log("CONFLICT IN PICKUP ORDER: ", plan[i]);
        //           corr_plan = [];
        //           corr_plan = corr_plan.concat(plan.slice(0, j));
        //           corr_plan = corr_plan.concat(plan.slice(i, i + 1));
        //           corr_plan = corr_plan.concat(plan.slice(j, i));
        //           corr_plan = corr_plan.concat(plan.slice(i + 1, plan.length));
        //           plan = corr_plan;

        //           i = 0;
        //           j = 0;
        //           break;
        //         }
        //       }
        //     }
        //   }
        // }
      }

      all_plans.push(plan);
    }

    // print the generated plans
    for (let r = 0; r < this.nriders; r++) {
      console.log("Plan for Rider ", this.riders[r].name);
      for (const act of all_plans[r]) {
        act.printAction();
      }
    }
    return [all_plans, best_fit];
  }

  /**
   * This is the function agents will call to generate a new plan.
   * A plan will be created and if it satisfies the fitness condition
   * it will be accepted, otherwise it will be rejected.
   */
  newPlan() {
    if (this.planLock) {
      console.log("Brain is already planning...");
      return;
    }
    this.planLock = true;

    let exp_decay = 0.9;
    let start = new Date().getTime();
    const [tmp_plan, best_fit] = this.createPlan();
    this.tot_time += new Date().getTime() - start;
    this.tot_plans += 1;
    this.plan_time_avg =
      exp_decay * this.plan_time_avg +
      (1 - exp_decay) * (this.tot_time / this.tot_plans);

    console.log("AVG plan generation ", this.tot_time / this.tot_plans, "ms");

    console.log("proposed fit ", best_fit, " current fit ", this.plan_fit);
    console.log("cache size: ", this.field.paths_cache.size);

    let curr_hit_rate =
      this.field.cache_hits / (this.field.cache_hits + this.field.cache_misses);

    this.field.hit_rate =
      exp_decay * this.field.hit_rate + (1 - exp_decay) * curr_hit_rate;
    this.field.cache_hits = 0;
    this.field.cache_misses = 0;
    console.log(
      "hit rate: ",
      Math.round(this.field.hit_rate * 10000) / 100,
      "%"
    );
    const MINIMUM_GAIN = 1.2;
    if (best_fit > this.plan_fit * MINIMUM_GAIN || this.plan_fit == 0) {
      this.plan_fit = best_fit;

      for (let i = 0; i < this.nriders; i++) {
        this.riders[i].plan = tmp_plan[i];
      }

      console.log("New plan accepted ✅");
    } else {
      console.log("New plan rejected ❌");
    }

    this.planLock = false;
  }

  /**
   *  This is a utility function used to print the matrix of costs
   *  representing the graph of the parcels used by the genetic algorithm.
   *
   * @param {Array.Array} mat
   */
  printMat(mat) {
    let str = "\\ \t";
    for (let i = 0; i < mat.length; i++) {
      str += i + "\t";
    }
    str += "\n";
    for (const row of mat) {
      str += mat.indexOf(row) + "\t";
      for (const cell of row) {
        let val = cell;
        if (cell > 9000) {
          val = "∞";
        }
        str += val + "\t";
      }
      str += "\n";
    }
    console.log(str);
  }
}

================
File: master_rider.js
================
import { Position } from "./data/position.js";
import { Action, ActionType } from "./data/action.js";
import { Genetic } from "./master_geneticBrain.js";
import { DeliverooApi } from "@unitn-asa/deliveroo-js-client";

/**
 * A rider is a player in the game. This class contains
 * all the information about the player's state and actions.
 *
 * @param {string} uname The username of the rider
 *
 * @property {number} carrying amount of points the rider is carrying
 * @property {Array} plan list of actions the rider will take
 * @property {number} no_delivery amount of turns since the rider last delivered
 * @property {Object} config configuration of the game
 * @property {string} uname username of the rider
 * @property {boolean} player_init whether the player has been initialized
 * @property {boolean} putting_down whether the player is putting down a parcel
 * @property {number} plan_cooldown turns until the player can plan again
 * @property {Map} player_parcels parcels the player is carrying
 * @property {Map} blocking_agents agents that are blocking the player
 * @property {Genetic} brain the player's brain
 * @property {DeliverooApi} client the player's client
 * @property {number} id the player's id
 * @property {string} name the player's name
 * @property {number} score the player's score
 * @property {Position} position the player's position
 * @property {Position} src the player's action source position
 * @property {Position} trg the player's action target position
 * @property {Action} nextAction the player's next action
 */
export class Rider {
  constructor(uname) {
    this.uname = uname;

    // Game state
    this.carrying = 0;
    this.plan = [];
    this.no_delivery = 0;
    this.config = {};
    this.player_init = false;
    this.putting_down = false;
    this.plan_cooldown = 0;
    this.player_parcels = new Map();
    this.blocking_agents = new Map();

    //this.brain = new Genetic(this.blocking_agents);
    this.client = new DeliverooApi(
      "http://localhost:8080/?name=" + this.uname,
      ""
    );

    console.log("Rider created");
  }

  /**
   *
   * @param {string} id  id of the rider
   * @param {string} name  name of the rider
   * @param {{x:number, y:number}} position  starting position of the rider
   * @param {Genetic} brain  brain of the rider
   */
  init(id, name, position, brain) {
    this.id = id;
    this.name = name;
    this.brain = brain;

    // Movement state
    this.position = position;
    this.src = new Position(position.x, position.y);
    this.trg = new Position(position.x, position.y);
    this.nextAction = null;
  }

  /**
   * @param {Map} config configuration of the game
   */
  setConfig(config) {
    this.config = config;
    console.log("Config received: ", this.config);
  }

  /**
   * @param {number} x x coordinate of the player
   * @param {number} y y coordinate of the player
   */
  updatePosition(x, y) {
    this.position.x = x;
    this.position.y = y;
  }

  /**
   * Checks whether the target of the current action
   * is blocked by another agent
   *
   * @returns {boolean} whether the target is blocked
   */
  isPathBlocked() {
    let blocked = false;
    for (const a of this.blocking_agents.values()) {
      if (a.x == this.trg.x && a.y == this.trg.y) {
        blocked = true;
        break;
      }
    }
    return blocked;
  }

  /**
   * Function to log messages with the player's name
   *
   * @param  {...any} args arguments to log
   */
  log(...args) {
    console.log("[", this.name, "] ", ...args);
  }
}

================
File: multi_dashboard.html
================
<!-- index.html -->
<link href="/path/to/dashboard.css" />
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dashboard</title>
  </head>
  <body>
    <h1>GlovoJS</h1>

    <div id="mapdiv">
      <table
        id="myTable"
        class="table table-borderless table-striped table-earning"
      >
        <tbody id="mapTable"></tbody>
      </table>
    </div>
    <div id="info"></div>
    <div id="carrying"></div>
    <div id="carrying_points"></div>

    <div id="carry_div"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      socket.on("update", (data) => {
        document.getElementById("updates").innerText = JSON.stringify(data);
      });

      socket.on("map", (data) => {
        w = data["map_size"][0];
        h = data["map_size"][1];
        tiles = data["tiles"];
        parcels = data["parc"];
        riders = data["riders"];

        let pathcolors = [
          "blue",
          "violet",
          "grey",
          "darkgreen",
          "black",
          "white",
        ];
        let ridercolor = [
          "lightblue",
          "pink",
          "lightgrey",
          "MediumSeaGreen",
          "darkgrey",
          "white",
        ];
        //   document.getElementById('info').innerHTML = "<div><h2>"+plan_target+"</h2><div>";

        //   document.getElementById('carrying').innerHTML = "<div>"+rider_parcels.map((el, idx) => {
        //   return (el.key);
        //  });"<div>";

        //  document.getElementById('carrying_points').innerHTML =  "<div><h2>"+carrying+" points </h2><div>";

        const table = document.getElementById("mapTable");
        table.innerHTML = "";

        // console.log(data["parc"]);

        for (let i = 0; i < h; i++) {
          let y = h - i - 1;
          let row = table.insertRow();

          for (let j = 0; j < w; j++) {
            let x = j;

            let tile = row.insertCell();

            tile_html = "<div style='display: table;width:100%;height:100%;'>";
            tile.style.width = "20px";
            tile.style.height = "20px";
            let color = "black";
            switch (tiles[y][j]["type"]) {
              case "W":
                color = "green";
                break;
              case "D":
                color = "red";
                break;
            }

            cell_id = x + "-" + y;
            //console.log(str);
            let pardone = false;
            let to_pickup = false;
            for (let rid = 0; rid < riders.length; rid++) {
              plan_move = riders[rid].plan[0];
              plan_pickup = riders[rid].plan[1];
              plan_drop = riders[rid].plan[2];
              blk_agents = riders[rid].blk_agents;

              if (plan_move.includes(cell_id)) {
                pathcolor = pathcolors[rid];
                tile_html +=
                  "<div style='width:80%;height:80%;background-color:" +
                  pathcolor +
                  ";'></div>";
              }

              if (!pardone) {
                for (p of parcels) {
                  if (p.x == x && p.y == y) {
                    color = "yellow";
                    tile_html +=
                      "<div style='position: absolute;'><b>" +
                      p.reward +
                      "</b></div>";
                  }
                }
                pardone = true;
              }

              if (plan_pickup.includes(cell_id)) {
                to_pickup = true;
                //color = "GreenYellow";
              } else if (plan_drop.includes(cell_id)) {
                color = "orange";
              }
            }
            if (to_pickup) {
              color = "GreenYellow";
            }
            for (let rid = 0; rid < riders.length; rid++) {
              blk_agents = riders[rid].blk_agents;

              if (blk_agents.includes(cell_id)) {
                color = "purple";
              }
            }
            tile_html += "</div>";

            tile.innerHTML = tile_html;
            tile.style.backgroundColor = color;
          }
          let tile = row.insertCell();
          tile.innerHTML = "<div>" + y + "</div>";
        }
        let row = table.insertRow();
        for (let j = 0; j < w; j++) {
          let tile = row.insertCell();
          tile.innerHTML = "<div>" + j + "</div>";
        }

        for (let rid = 0; rid < riders.length; rid++) {
          rider = riders[rid];

          table.rows[Math.round(h - rider.y) - 1].cells[
            Math.round(rider.x)
          ].innerHTML = "<div ></div>";
          table.rows[Math.round(h - rider.y) - 1].cells[
            Math.round(rider.x)
          ].style.backgroundColor = ridercolor[rid];
        }

        // TABLE OF CARRIED PARCELS

        const carry_div = document.getElementById("carry_div");
        carry_div_html = "";

        for (let rid = 0; rid < riders.length; rid++) {
          carry_div_html +=
            '<table style="border: 1px solid black;display: inline-block;" id="my_carry_table">';
          carry_div_html += '<tbody id="carry_table' + rid + '"></tbody>';
          carry_div_html += "</table>";
        }
        carry_div.innerHTML = carry_div_html;
        console.log(carry_div.innerHTML);

        for (let rid = 0; rid < riders.length; rid++) {
          let carry_table = document.getElementById("carry_table" + rid);
          carry_table.innerHTML = "";
          rider_parc = riders[rid].parcels;
          // console.log("rp: ", rider_parc);
          for (let i = 0; i < rider_parc.length; i++) {
            let row = carry_table.insertRow();

            row.style.border = "1px solid #000";

            let rider_cell = row.insertCell();
            let key_cell = row.insertCell();
            let rew_cell = row.insertCell();

            rider_cell.style.border = "1px solid #000";
            rider_cell.style.backgroundColor = ridercolor[rid];
            key_cell.style.border = "1px solid #000";
            rew_cell.style.border = "1px solid #000";

            parcel = rider_parc[i];

            rider_cell.innerHTML = "<div><b>Rider " + rid + "</b></div>";
            key_cell.innerHTML = "<div><b>" + parcel.key + "</b></div>";
            rew_cell.innerHTML = "<div><b>" + parcel.reward + "</b></div>";
          }
        }
      });
    </script>
  </body>
</html>

================
File: package.json
================
{
  "name": "asa_glovojs",
  "version": "1.0.0",
  "description": "helo",
  "type": "module",
  "main": "index.js",
  "module": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node master_agent.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@unitn-asa/deliveroo-js-client": "^0.0.37",
    "@unitn-asa/pddl-client": "^0.0.37",
    "express": "^4.19.2",
    "node-fetch": "^3.3.0",
    "socket.io": "^4.7.5",
    "socket.io-client": "^4.6.0"
  }
}

================
File: README.md
================
# ASA_Glovojs

## NOTES

- high populations seem to work better in more open maps whereas low populations work better in more closed maps. Might be due to the higher chance of replanning in busier maps that penalize the high pupulation agent since planning is more costly and it impacts the speed of the agent. While the plans might be better the speed of the "dumber" agents allows them to steal parcels and deliver them faster.

## TODO

- [x] Define interfaces
- [x] Implement actions data structure
- [x] Implement actions actuation
- [x] Implement dashboard
- [x] Implement planner
- [x] Improve reasoning to pick up multiple parcels instead of delivering asap
- [x] Stop going after parcels that have already been delivered
- [x] Anytime the agent steps on a parcel, pick it up
- [x] Anytime the agent steps on a delivery zone, deliver
- [x] (kinda) Prevent moving to unreachable tiles
- [x] Contain all planning inside the brain
- [x] Make sure planner doesnt miss new or previously discovered parcels
- [x] Planner must consider other agent's positions
- [x] Planner must make sure agent can get unstuck
- [x] Make sure planner doesnt forget he's carrying parcels when replanning
- [x] Double check for closest delivery point

- [x] Make sure agent knows how much (and how many parcels) he can carry when replanning
- [x] Penalize overly long paths
- [x] make sure agent forgets parcels left in memory when the tile comes back in view and the parcel is gone

- [x] Make sure agent doesnt crash when NO plan is found (og no parcels, no delivery zones, no reachable tiles)

- [x] reimplement agent blocking logic

- [x] fix crossover for multiple agents
- [x] make sure player_parcels are handled correctly in the planner
- [x] make sure parcels are correctly memorized
- [x] fix bfs crashing when position is not round
- [x] penalize too many plan changes
- [x] check if carried parcels are correcly evaluated when replanning
- [x] rework parcels clock
- [x] figure out why agent crashes when 2-action long backup plan is created and after consuming action

- [x] make sure it's possible to generate a plan with delivery only in case one agent has parcels
- [x] fix the stuff about fitness in delivery only
- [x] rethink logic when it's time to replan (due to delivery or plan end)

- [x] fix dashboard now highlighting all the parcels to be picked up
- [x] fix plans swapping between agents (might be an indexing issue)
- [x] make sure a valid plan is created if one agent has no reachable parcels
- [x] make sure in geneticTSP when one rider has no nodes (so zero genes) it doesn't happen that a random plan is generated for ALL riders.
- [?] fix agent not seeing (?) parcel when in the same cell (might be due to delayed replanning OR too short bfs)

- [ ] fix order of parcels in plan generation
- [x] add caching system for bfs
- [ ] make sure cache doesn't get too big
- [ ] penalize riders that don't deliver for too long (exp in case of non-decaying parcels)
- [ ] add replanning when parcels are stolen
- [x] clean code
- [x] search&destroy legacy variables
- [x] reimplement parcel decay in fitness
- [x] is the dummy_parcel in builGraphInOut even needed? (might be a leftover from the old implementation)
- [x] make sure chances are computed correctly in rouletteWheel, in particular in case of negative fit (for the moment I set a lower bound for fitness as -Infinity screws with the probabilities and removed the rounding of the chances) THIS MUST BE VERIFIED
- [x] dynamically change STEP_COST and penalities based on the config
- [ ] exponential decay for metrics might not be that beneficial
- [x] reimplement parcels clock

================
File: server.js
================
// server.js
import { Server } from "socket.io";
import http from "http";
import express from "express";
import path from "path";

export class MyServer {
  constructor(port) {
    this.app = express();
    this.server = http.createServer(this.app);
    this.io = new Server(this.server);
    console.log("Server constructor: ", port);
    this.port = port;
    this.start();
    this.serveDashboard();
  }

  serveDashboard() {
    this.app.get("/", (req, res) => {
      const dashboardPath = new URL("./multi_dashboard.html", import.meta.url)
        .pathname;
      const decodedPath = decodeURIComponent(dashboardPath);
      const normalizedPath = path.normalize(decodedPath);
      console.log(normalizedPath);
      res.sendFile(normalizedPath);
    });
  }

  start() {
    // let rando_port = Math.floor(Math.random() * 10000) + 1;
    // rando_port = 3000;
    this.server.listen(this.port, () => {
      console.log("Dashboard server running on http://localhost:" + this.port);
    });
  }

  emitMessage(event, data) {
    this.io.emit(event, data);
  }
}

// export default new MyServer();

================
File: utils.js
================
/**
 * Sorts an array of objects by a key
 *
 * @param {Array} array
 * @param {string} key
 * @returns {Array}
 */
export function sortByKey(array, key) {
  return array.sort(function (a, b) {
    var x = a[key];
    var y = b[key];
    return x < y ? -1 : x > y ? 1 : 0;
  });
}

/**
 * Returns the Manhattan distance between two points,
 * a and b can be either Position or {x:number, y:number}
 *
 * @param {Position} a
 * @param {Position} b
 *
 * @returns {number}
 */
export function manhattanDistance(a, b) {
  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

/**
 * Checks whether a a position is fully aligned with the grid
 *
 * @param {Position} pos
 */
export function hasCompletedMovement(pos) {
  return pos.x % 1 === 0.0 && pos.y % 1 === 0.0;
}

================
File: dashboard.css
================
table {
    width: 90%;
  }
td {
width: 100px;
position: relative;
}

================
File: index.js
================
#!/usr/bin/env node
import { DeliverooApi, timer } from "@unitn-asa/deliveroo-js-client";
import * as pddlClient from "@unitn-asa/pddl-client";

================
File: master_agent.js
================
console.log("Starting...");
import { Field } from "./data/field.js";
import { Position } from "./data/position.js";
import { MyServer } from "./server.js";
import { Action, ActionType } from "./data/action.js";
import { Rider } from "./master_rider.js";
import { Genetic } from "./master_geneticBrain.js";
import { Beliefset } from "@unitn-asa/pddl-client";

import { manhattanDistance, hasCompletedMovement } from "./utils.js";
import { bfs_pddl } from "./planner/bfs_pddl.js";

export const VERBOSE = false;
const LOCAL = true;
export const USE_PDDL = true;

let [NRIDERS, POP, GEN, PORT] = process.argv.slice(2);
if (NRIDERS == undefined) {
  NRIDERS = 1;
}
if (POP == undefined) {
  POP = 100;
}
if (GEN == undefined) {
  GEN = 30;
}

if (PORT == undefined) {
  PORT = 3000;
}

console.log("Population: ", POP);
console.log("Generations: ", GEN);

const dashboard = new MyServer(PORT);

let map_init = false;
const map = new Field(USE_PDDL); // contains the game map
const parcels = new Map(); // contains all non-carried parcels

let PARCEL_DECAY = 1000;

class Intention {
  goal;
  type;
  pickUp;
  deliver;
  stop;
  reached;
  started;
  planner = { 'pickup': bfs_pddl }
  move;

  constructor(goal, pickUp = false, deliver = false, type, client) {
    this.goal = goal;
    this.pickUp = pickUp;
    this.deliver = deliver;
    this.type = type;
    this.stop = false;
    this.reached = false;
    this.started = false;
    this.move = {

    }
  }
}

// create riders
let riders = [];
let names = ["BLUE", "PINK", "GREY", "GREEN", "BLACK", "WHITE"];
for (let i = 0; i < NRIDERS; i++) {
  //let uname = Math.random().toString(36).substring(5) + "_" + pop + "_" + gen;
  let uname = names[i] + "_" + POP + "_" + GEN;
  riders.push(new Rider(uname));
}

//create brain with associated riders
let brain = new Genetic(riders, map, parcels, POP, GEN);
let agentsBeliefSet;
let parcelsBeliefSet;

// set up sensings for all riders
riders.forEach((rider, index) => {
  rider.client.onConfig((config) => {
    rider.setConfig(config);
    brain.setConfig(config);

    if (config.PARCEL_DECADING_INTERVAL == "infinite") {
      PARCEL_DECAY = Infinity;
    } else {
      PARCEL_DECAY = config.PARCEL_DECADING_INTERVAL * 1000;
    }
  });

  // note that this happens before the onYou event
  rider.client.onMap((width, height, tiles) => {
    VERBOSE && console.log("Map received. Initializing...");

    //init map only once
    if (!map_init) {
      map.init(width, height, tiles);
      map_init = true;
    }
    //rider.brain.init(map, parcels, new Position(0, 0), pop, gen);
  });

  rider.client.onYou(({ id, name, x, y, score }) => {
    if (!rider.player_init) {
      rider.init(id, name, new Position(x, y), brain);
      rider.player_init = true;
      rider.trg.set(rider.position);
    }
    rider.updatePosition(x, y);
  });

  parcelsBeliefSet = new Beliefset();

  rider.client.onParcelsSensing(async (perceived_parcels) => {
    let parc_before = Array.from(parcels.keys());

    // if memorized parcels in the sensing range are not present
    // anymore, remove them from the parcels list
    for (const [key, value] of parcels.entries()) {
      let parc_pos = new Position(value.x, value.y);
      let found = false;
      let dist = manhattanDistance(rider.position, parc_pos);

      if (dist < rider.config.PARCELS_OBSERVATION_DISTANCE) {
        for (const p of perceived_parcels) {
          if (p.id == key && p.carriedBy == null) {
            parcelsBeliefSet.declare(`parcel_t${p.x}_${p.y}`);
            found = true;
            break;
          }
        }
        if (!found) {
          parcelsBeliefSet.undeclare(`parcel_t${value.x}_${value.y}`);
          parcels.delete(key);
        }
      }
    }

    // update and add free parcels and
    // update rider parcels and carried value
    let carried_parcels = new Map();
    let carrying = 0;
    for (const p of perceived_parcels) {
      if (p.carriedBy == null) {
        parcels.set(p.id, p);
      } else if (p.carriedBy == rider.id) {
        carried_parcels.set(p.id, p.reward);
        carrying += p.reward;
      }
    }

    // if rider is in the process of putting down and the
    // sensing reveals that the rider is not carrying any parcels,
    // confirm delivery and ask for new plan. Otherwise, update carrying value
    if (rider.putting_down) {
      if (carrying <= 0) {
        rider.carrying = 0;
        rider.player_parcels.clear();

        rider.log("Delivered, asking for new plan");
        brain.plan_fit = 0;
        brain.newPlan();
        rider.putting_down = false;
      }
    } else {
      rider.carrying = carrying;
      rider.player_parcels = carried_parcels;
    }

    let parc_after = Array.from(parcels.keys());

    // if parcels have changed during the sensing, recalculate plan
    let changed = JSON.stringify(parc_before) != JSON.stringify(parc_after);
    if (changed) {
      console.log("Parcels changed. Recalculating plan");
      brain.newPlan();
    }
  });

  agentsBeliefSet = new Beliefset();

  rider.client.onAgentsSensing(async (perceived_agents) => {
    // if other agents are within BLOCKING_DISTANCE blocks
    // of the rider, add them to its blocking_agents list

    // reset blocking agents every time the sensing is updated
    rider.blocking_agents.clear();
    // clear belief set
    // for (const a of perceived_agents) {
    //   agentsBeliefSet.undeclare(`agent_t${a.x}_${a.y}`);
    // }
    // Undeclare all agents currently stored in the belief set
    agentsBeliefSet.objects.forEach((obj) => {
      agentsBeliefSet.undeclare(obj);
    });


    let BLOCKING_DISTANCE = 100;
    for (const a of perceived_agents) {
      if (a.name != "god") {
        if (manhattanDistance(rider.position, a) < BLOCKING_DISTANCE) {
          rider.blocking_agents.set(a.id, a);
          agentsBeliefSet.declare(`agent_t${a.x}_${a.y}`);
        }
      }
    }
  });
});
  

// PARCELS CLOCK
setInterval(() => {
  riders.forEach((rider) => {
    // reduce reward of parcels that are not in the sensing range
    for (const [key, value] of parcels.entries()) {
      let parc_pos = new Position(value.x, value.y);
      let dist = manhattanDistance(rider.position, parc_pos);
      if (dist >= rider.config.PARCELS_OBSERVATION_DISTANCE) {
        value.reward--;
        if (value.reward <= 0) {
          parcels.delete(key);
        } else {
          parcels.set(key, value);
        }
      }
    }
  });
}, PARCEL_DECAY);

// DASHBOARD UPDATE
setInterval(() => {
  //organize all the logging data to be sent to the dashboard
  let update_map = map.getMap();
  let riders_data = [];

  riders.forEach((rider) => {
    if (rider.player_init) {
      let plan_move = [];
      let plan_pickup = [];
      let plan_drop = [];
      let rider_parcels = [];

      if (rider.plan.length > 0) {
        for (const p of rider.plan) {
          let move_id = Position.serialize(p.source);
          switch (p.type) {
            case ActionType.MOVE:
              plan_move.push(move_id);
              break;
            case ActionType.PICKUP:
              plan_pickup.push(move_id);
              break;
            case ActionType.PUTDOWN:
              plan_drop.push(move_id);
              break;
          }
        }
      }

      if (rider.player_parcels.size > 0) {
        for (const [key, p] of rider.player_parcels.entries()) {
          rider_parcels.push({ key: key, reward: p });
        }
      }

      let blk_agents = [];
      for (const blk of rider.blocking_agents.values()) {
        blk_agents.push(blk.x + "-" + blk.y);
      }   

      riders_data.push({
        x: rider.position.x,
        y: rider.position.y,
        plan: [plan_move, plan_pickup, plan_drop],
        parcels: rider_parcels,
        blk_agents: blk_agents,
      });
    }
  });
  let dash_parcels = [];
  for (const [key, p] of parcels.entries()) {
    dash_parcels.push({ x: p.x, y: p.y, reward: p.reward });
  }

  let dash_data = {
    map_size: [map.width, map.height],
    tiles: update_map,
    riders: riders_data,
    parc: dash_parcels,
  };

  dashboard.emitMessage("map", dash_data);
}, 100);

let start = Date.now();

/**
 * Main loop for the agents
 *
 * @param {Rider} rider
 */
async function loop(rider) {
  // main loop
  while (true) {
    // wait for map and player to be loaded
    if (!rider.player_init) {
      await new Promise((res) => setTimeout(res, 300));
      continue;
    }

    // if a plan exists execute, otherwise create a new one
    if (rider.plan.length > 0) {
      // if the agent has completed the movement and brain has completed the plan
      if (hasCompletedMovement(rider.position) && !brain.planLock) {
        // pick action from plan (depending on when planning was started
        // agent might at the first or second step)
        if (rider.position.equals(rider.plan[0].source)) {
          rider.nextAction = rider.plan.shift();
        } else if (rider.plan.length > 1) {
          if (rider.position.equals(rider.plan[1].source)) {
            rider.nextAction = rider.plan.shift();
            rider.nextAction = rider.plan.shift();
          } else {
            rider.log("No match found for next action");
            rider.log(rider.position);
            rider.log(rider.nextAction);
            rider.log(
              "should be ",
              rider.plan[0].source,
              " OR ",
              rider.plan[1].source
            );
          }
        } else {
          rider.log("Agent appears to be stuck on last move");
          rider.log("Retrying last move");
        }

        //update agent position and target
        rider.src.set(rider.nextAction.source);
        rider.trg.set(rider.nextAction.target);
        rider.no_delivery++;

        // extract action information
        let move = Position.getDirectionTo(rider.src, rider.trg);

        // check if the path is blocked
        if (rider.isPathBlocked()) {
          rider.trg.set(rider.position);
          rider.log("Agent in the way. Recalculating plan");
          brain.plan_fit = 0;
          await brain.newPlan();
          continue;
        }
        
        // Use the current position as start and the target as end
        let start = new Position(Math.round(rider.position.x), Math.round(rider.position.y));
        let end = new Position(rider.trg.x, rider.trg.y);
        
        let path = await map.bfsWrapper(start, end, rider.blocking_agents);
        
        if (path === -1) {
            rider.log("No path found. Recalculating plan");
            brain.plan_fit = 0;
            await brain.newPlan();
            continue;
        }

        //avoid server spam
        while (Date.now() - start < rider.config.MOVEMENT_DURATION / 2) {
          await new Promise((res) => setImmediate(res));
        }
        start = Date.now();

        //execute action
        switch (rider.nextAction.type) {
          case ActionType.MOVE:
            if (move != "none") {
              await rider.client.move(move);
            }
            break;
          case ActionType.PICKUP:
            await rider.client.pickup();

            try {
              rider.player_parcels.set(
                rider.nextAction.action_parcel,
                parcels.get(rider.nextAction.action_parcel).reward
              );
              parcels.delete(rider.nextAction.action_parcel);
            } catch (error) {
              rider.log(
                "Parcel either expired or was deleted while executing plan."
              );
            }
            rider.log("PICKING UP ", rider.nextAction.action_parcel);
            break;
          case ActionType.PUTDOWN:
            rider.log("PUTTING DOWN");
            await rider.client.putdown();

            if (!rider.putting_down && rider.carrying > 0) {
              rider.putting_down = true;
            }
            break;
        }
      }
    } else {
      if (rider.putting_down) {
          rider.log("Empty plan but waiting for delivery to complete");
      } else {
          if (Date.now() - rider.plan_cooldown > 1000) {
              rider.plan_cooldown = Date.now();
              rider.log("Plan is empty. Recalculating plan");
              brain.plan_fit = 0;
              await brain.newPlan();
          }
      }
    }
  await new Promise((res) => setImmediate(res));
  }
}

// start the loop for all riders
for (let i = 0; i < riders.length; i++) {
  loop(riders[i]).catch(error => console.error(`Error in loop for rider ${i}:`, error));
}

export { parcelsBeliefSet, agentsBeliefSet, map }

================
File: master_geneticBrain.js
================
import { Position, Direction } from "./data/position.js";
import { Action, ActionType } from "./data/action.js";
import { Field } from "./data/field.js";
import { Rider } from "./master_rider.js";
import { sortByKey } from "./utils.js";

/**
 * @class Genetic
 *
 * Contains the genetic algorithm for the planning of the agents,
 * it generates a plan for each agent based on the current state of the
 * entire field and the agents. The plan will be an approximation of
 * of a variation of the Travelling Salesman Problem that takes into
 * account the rewards of the parcels and and the cost of reaching them.
 *
 * @property {Array} riders - The list of all the controlled agents
 * @property {number} nriders - The number of controlled agents
 * @property {Object} config - The configuration object received from the server
 * @property {Field} field - The field object containing the map
 * @property {Map} parcels - The map of all the parcels on the field
 * @property {number} pop - The size of the population for the genetic algorithm
 * @property {number} gen - The number of generations for the genetic algorithm
 * @property {number} plan_fit - The fitness of the current plan
 * @property {Boolean} planLock - A flag to prevent multiple plans from being generated
 * @property {number} tot_time - The total time spent generating plans [metrics]
 * @property {number} tot_plans - The total number of plans generated [metrics]
 */
export class Genetic {
  constructor(riders, field, parcels, pop, gen) {
    //riders
    this.riders = riders;
    this.nriders = riders.length;

    //brain settings
    this.field = field;
    this.parcels = parcels;
    this.plan_fit = 0;
    this.planLock = false;
    this.config = {};

    //Genetic params
    this.pop = pop;
    this.gen = gen;

    //metrics
    this.tot_time = 0;
    this.tot_plans = 0;
    this.plan_time_avg = 0;

    console.log("Genetic brain created with ", this.nriders, " riders");
  }

  /**
   *
   * @param {Object} config - The configuration object received from the server
   */
  setConfig(config) {
    this.config = config;
    console.log("Config received: ", this.config);

    let parcel_decay = parseFloat(this.config.PARCEL_DECADING_INTERVAL);
    if (isNaN(parcel_decay)) {
      if (this.config.PARCEL_DECADING_INTERVAL === "infinite") {
        this.config.PARCEL_DECADING_INTERVAL = 10;
      } else {
        this.config.PARCEL_DECADING_INTERVAL = 0;
      }
    } else {
      this.config.PARCEL_DECADING_INTERVAL = parcel_decay;
    }
  }

  /**
   * Translates the parcels on the field into a graph representation
   * that can be used to generate a plan for the agents.
   *
   * @param {Rider} rider - The rider for which the graph is being generated
   *
   * @returns {[Array, Array, Array]} - The costs, paths and prep_parcels of the graph,
   * costs and paths are both 2-dimensional arrays corresponding to the costs
   * and paths between each pair of nodes, prep_parcels corresponds the the nodes of the graph,
   * each element contains the coordinates and reward of the parcel and  costs and paths both to get
   * there form the player position and to get to the closest delivery zone.
   */
  async builGraphInOut(rider) {
    let prep_parcels = [];
    let costs = [];
    let paths = [];

    // prepare each parcel for the graph
    for (const [key, p] of this.parcels.entries()) {
        // compute the cost and path from the player to the parcel
        let start = this.field.getTile({ x: p.x, y: p.y });
        let end = this.field.getTile({ x: rider.trg.x, y: rider.trg.y });
        let path_from_player = await this.field.bfsWrapper(start, end, rider.blocking_agents);
        let cost_from_player;
        if (path_from_player == -1) {
            cost_from_player = Infinity;
        } else {
            cost_from_player = path_from_player.length - 1;
        }

        // compute the cost and path from the parcel to the closest delivery zone
        start = { x: p.x, y: p.y };
        let path_to_zone;
        let cost_to_zone;
        let closest = await this.field.getClosestDeliveryZones(
            start,
            rider.blocking_agents
        );

        if (closest.length == 0) {
            cost_to_zone = Infinity;
            path_to_zone = -1;
        } else {
            path_to_zone = closest[0].path;
            cost_to_zone = closest[0].distance - 1;
        }

        let inc = cost_from_player;
        let outc = cost_to_zone;

        prep_parcels.push({
            x: p.x,
            y: p.y,
            rew: p.reward,
            in_c: inc,
            out_c: outc,
            id: key,
            path_in: path_from_player,
            path_out: path_to_zone,
        });
    }

    // build graph matrices
    for (let i = 0; i < prep_parcels.length; i++) {
        costs[i] = [];
        paths[i] = [];

        for (let j = 0; j < prep_parcels.length; j++) {
            if (i == j) {
                costs[i][j] = Infinity;
            } else {
                let stTile = this.field.getTile({
                    x: prep_parcels[i].x,
                    y: prep_parcels[i].y,
                });

                let endTile = this.field.getTile({
                    x: prep_parcels[j].x,
                    y: prep_parcels[j].y,
                });

                let path = await this.field.bfsWrapper(endTile, stTile, rider.blocking_agents);
                if (path.length == 0 || path == -1) {
                    costs[i][j] = Infinity;
                    paths[i][j] = [];
                } else {
                    paths[i][j] = path;
                    costs[i][j] = path.length;
                }
            }
        }
    }

    return [costs, paths, prep_parcels];
}


  /**
   * Removes a random number of elements from a list
   *
   * @param {Array} list - The list to be masked
   * @returns {Array} - The masked list
   */
  maskList(list) {
    let num_del = list.length - (Math.floor(Math.random() * list.length) + 1);

    for (let i = 0; i < num_del; i++) {
      let idx = Math.floor(Math.random() * list.length);
      list.splice(idx, 1);
    }
    return list;
  }

  /**
   * Generates the scores and chances for the roulette wheel selection
   * of the genetic algorithm
   *
   * @param {Array} population - The population of the genetic algorithm
   * @param {Array} riders_graphs - The paths of the riders
   *
   * @returns {[Array, Array]} - The scores and chances (to be picked) of the population
   */
  rouletteWheel(population, riders_graphs) {
    let scores = [];
    let tot_fit = 0;
    let min_fit = 0;
    for (const family of population) {
      let [fit, _] = this.fitness(family, riders_graphs);
      if (fit < 0) {
        fit = 0;
      }
      scores.push(fit);
      if (fit < min_fit) {
        min_fit = fit;
      }
    }

    for (const score of scores) {
      tot_fit += score - min_fit;
    }

    let chances = [];
    for (const score of scores) {
      let chance = ((score - min_fit) / (tot_fit + 1)) * scores.length;
      chances.push(chance);
    }

    return [scores, chances];
  }

  /**
   * Returns the elite individuals, the
   * best 'elite_rate %' of the population
   *
   * @param {Array} population - The population of the genetic algorithm
   * @param {Array} scores - The scores of the population
   * @param {number} elite_rate - The percentage of the population to be considered elite
   *
   * @returns {Array} - The elite individuals
   */
  getElites(population, scores, elite_rate) {
    let mapped = scores.map((el, idx) => {
      return { index: idx, score: el };
    });

    mapped = sortByKey(mapped, "score");

    let elites = [];
    let num_elites = Math.round(mapped.length * elite_rate);
    for (let i = 0; i < num_elites; i++) {
      elites.push(mapped[mapped.length - i - 1].index);
    }

    let elite_dna = [];
    for (const idx of elites) {
      elite_dna.push(population[idx]);
    }
    return elite_dna;
  }

  /**
   * Picks an individual from the population based on the chances
   * computed by the roulette wheel selection
   *
   * @param {Array} population - The population of the genetic algorithm
   * @param {Array} chances - The chances of each individual to be picked
   *
   * @returns {Array} - The picked individual
   */
  pickOne(population, chances) {
    let val = Math.random();
    let cum = 0;
    let norm = [];

    for (const chance of chances) {
      cum += chance;
    }
    for (const chance of chances) {
      norm.push(chance / cum);
    }
    let idx = 0;
    while (val > 0) {
      val -= norm[idx];
      idx++;
    }
    idx--;

    return population[idx];
  }
  /**
   * Performs a multi-crossover between two parents, each parent
   * is composed of a list of DNAs (one for each rider) where the DNA
   * corresponds to the sequence of parcels to be picked up.
   * Each DNA will be crossed with the corresponding DNA of the other parent
   * and duplicate parcels will be removed starting from the longest sequence.
   *
   * @param {Array} parentA - The first parent
   * @param {Array} parentB - The second parent
   *
   * @returns {Array} - The crossed children
   */
  multiCrossover(parentA, parentB) {
    let childs = [];

    // perform crossover for each rider.
    // Each DNA is split in half and child is composed of the head of
    // one parent and the tail of the other parent. Elements are added
    // one by one making sure that no duplicates are present.
    for (let r = 0; r < this.nriders; r++) {
      let dnaA = parentA[r];
      let dnaB = parentB[r];

      let seg_len = Math.floor(dnaA.length / 2);

      let start = Math.floor((dnaA.length - seg_len) / 2);
      let end = start + seg_len;

      let a_segment = dnaA.slice(start, end);
      let head = [];
      let tail = [];

      for (const el of dnaB) {
        if (!a_segment.includes(el)) {
          if (head.length <= dnaA.length - seg_len) {
            head.push(el);
          } else if (head.length + tail.length < dnaA.length - seg_len) {
            tail.push(el);
          } else {
            break;
          }
        }
      }
      let child = [].concat(head).concat(a_segment).concat(tail);
      childs.push(child);
    }

    // creates a list of tuples containing the length of each DNA
    let subl_len = [];
    for (let i = 0; i < childs.length; i++) {
      subl_len.push({ len: childs[i].length, idx: i });
    }
    subl_len = sortByKey(subl_len, "len");

    // removes duplicate parcels from the childs starting from the longest
    let clean_childs = [];
    let dupl = new Set();
    for (const sub of subl_len) {
      let clean_child = [];
      let idx = sub.idx;
      for (const el of childs[idx]) {
        if (dupl.has(el)) {
        } else {
          clean_child.push(el);
          dupl.add(el);
        }
      }
      clean_childs.push(clean_child);
    }

    // orders the childs based on the original order
    let ordered_childs = [];
    for (let i = 0; i < clean_childs.length; i++) {
      ordered_childs[subl_len[i].idx] = clean_childs[i];
    }

    return ordered_childs;
  }

  /**
   * Computes the cost of a step (going from one node to the next)
   * based on the cost of reaching the node and the current
   * carrying capacity of the agent. The penalty is dinamically
   * computed based on the number of parcels the agent is carrying and
   * the decay of the parcels.
   *
   * @param {number} cost_in - The cost of reaching the parcel
   * @param {number} curr_carr - The current carrying capacity of the agent
   *
   * @returns {number} - The cost of the step
   */
  getStepCost(cost_in, curr_carr) {
    let decay_bonus = (this.config.PARCEL_DECADING_INTERVAL - 1) / 9;

    let STEP_COST = 0.5 - decay_bonus * 0.2;

    let cost = cost_in * STEP_COST * (curr_carr + 1);
    return cost;
  }

  /**
   * Computes the fitness of a family (a list of DNAs, one for each rider)
   * based on the paths of the riders and the delivery-only fits.
   *
   * The fitness is computed for plans containing parcels so delivery-only
   * plans are computed separately once and considered only if they are better
   * than all the other plans.
   *
   * @param {Array} family - The family of DNAs
   * @param {Array} riders_graphs - The graphs for each rider
   * @param {Array} delivery_only_fits - The delivery-only fits
   *
   * @returns {[Number, Array]} - The cumulative reward of the family and a list
   * of booleans indicating if that rider should deliver only
   */
  fitness(family, riders_graphs, delivery_only_fits = null) {
    let cumulative_rew = 0;
    let delivery_only = [];

    for (let r = 0; r < this.nriders; r++) {
      let delivery_only_fit = -Infinity;
      if (delivery_only_fits != null) {
        delivery_only_fit = delivery_only_fits[r];
      }

      let costs = riders_graphs[r].costs;
      let nodes = riders_graphs[r].nodes;
      let dna = family[r];
      let rew = 0;

      if (dna.length > 0) {
        let curr_carr = this.riders[r].player_parcels.size;

        // reward for the amount of points the rider is already carrying
        rew = this.riders[r].carrying;

        // reward of first parcel minus cost of reaching it
        rew +=
          nodes[dna[0]].rew - this.getStepCost(nodes[dna[0]].in_c, curr_carr);

        curr_carr += 1;

        // reward of each parcel in DNA minus cost of reaching it
        for (let i = 1; i < dna.length; i++) {
          rew +=
            nodes[dna[i]].rew -
            this.getStepCost(costs[dna[i - 1]][dna[i]], curr_carr);

          curr_carr += 1;
        }

        // cost of reaching the delivery zone fron the last parcel
        rew += -this.getStepCost(nodes[dna[dna.length - 1]].out_c, curr_carr); //* STEP_COST * curr_carr;
      } else {
        rew = 0;
      }

      // check if it's better to deliver only
      if (rew < delivery_only_fit && delivery_only_fit > 0) {
        cumulative_rew += delivery_only_fit;
        delivery_only.push(true);
      } else {
        cumulative_rew += rew;
        delivery_only.push(false);
      }
    }
    return [cumulative_rew, delivery_only];
  }

  /**
   * Generates a plan for the agents based on the genetic algorithm.
   * The script will create a starting random population of size 'pop_size'
   * and iterate for 'gen_num' generations. Each new generation will be
   * composed of the 'elite_rate'% of the best individuals of the previous
   * generation and the rest will be generated by crossover and mutation.
   *
   * @param {Array} riders_graphs - The graphs for each rider
   * @param {Array} delivery_only_fits - The delivery-only fits
   * @param {number} pop_size - The size of the population
   * @param {number} gen_num - The number of generations
   * @param {number} mutation_rate - The mutation rate
   * @param {number} elite_rate - The elite rate
   *
   * @returns {[Array, Number]} - The generated plan and its fitness
   */
  geneticTSP(
    riders_graphs,
    delivery_only_fits,
    pop_size = 1000,
    gen_num = 100,
    mutation_rate = 0.1,
    elite_rate = 0.5
  ) {
    let genes = [];

    // prepare the genes for the genetic algorithm
    for (let rid = 0; rid < this.nriders; rid++) {
      const r = riders_graphs[rid];

      genes = Array.from(Array(r.nodes.length).keys());

      if (genes.length == 0) {
        let empty_plan = Array.from({ length: this.riders.length }, () => []);
        console.log("No parcels in sight, returning empty plan ", empty_plan);
        return [empty_plan, 0];
      }
    }

    let best_d_o = [];
    let best_dna = [];
    let best_fit = 0;
    let population = [];

    // generate the initial population
    for (let i = 0; i < pop_size; i++) {
      let order = genes.slice();
      order = order.sort(() => Math.random() - 0.5);
      let masked = this.maskList(order);

      let slices = [];
      for (let j = 0; j < this.nriders - 1; j++) {
        slices.push(Math.round(Math.random() * (masked.length - 1)));
      }
      slices = slices.sort((a, b) => a - b);

      let family = [];

      family.push(masked.slice(0, slices[0]));
      for (let j = 1; j < slices.length; j++) {
        family.push(masked.slice(slices[j - 1], slices[j]));
      }
      if (slices.length > 0) {
        family.push(masked.slice(slices[slices.length - 1], masked.length));
      }

      population.push(family);
    }

    // iterate over the generations
    for (let i = 0; i < gen_num; i++) {
      let new_pop = [];

      //compute chance of each individual to be picked
      const [scores, chances] = this.rouletteWheel(population, riders_graphs);

      // get the elite (best) individuals
      let elites = this.getElites(population, scores, elite_rate);
      new_pop = new_pop.concat(elites);

      // generate the new population
      for (let j = 0; j < pop_size - elites.length; j += 2) {
        let parentA = this.pickOne(population, chances);
        let parentB = this.pickOne(population, chances);

        let childA = this.multiCrossover(parentA, parentB);
        let childB = this.multiCrossover(parentB, parentA);

        new_pop.push(childA);
        new_pop.push(childB);
      }

      // mutate the population
      for (let j = 0; j < new_pop.length; j++) {
        if (Math.random() < mutation_rate) {
          let idxFamA = Math.floor(Math.random() * new_pop[j].length);
          let idxFamB = Math.floor(Math.random() * new_pop[j].length);

          let idxA = Math.floor(Math.random() * new_pop[j][idxFamA].length);
          let idxB = Math.floor(Math.random() * new_pop[j][idxFamB].length);

          // adding padding to avoid indexing empty arrays
          for (let k = 0; k < new_pop[j].length; k++) {
            new_pop[j][k].push(-1);
          }

          let tmp = new_pop[j][idxFamA][idxA];
          new_pop[j][idxFamA][idxA] = new_pop[j][idxFamB][idxB];
          new_pop[j][idxFamB][idxB] = tmp;

          // removing padding
          for (let k = 0; k < new_pop[j].length; k++) {
            new_pop[j][k] = new_pop[j][k].filter((a) => a != -1);
          }
        }
      }

      population = new_pop;

      let tot_fit = 0;

      // saving the best family of the generation
      for (const family of population) {
        let [fit, d_o] = this.fitness(
          family,
          riders_graphs,
          delivery_only_fits
        );
        tot_fit += fit;

        if (fit > best_fit) {
          best_d_o = d_o;
          best_fit = fit;
          best_dna = JSON.parse(JSON.stringify(family));
        }
      }
      // console.log("Best DNA: ", best_dna);
      // if (i % 5 == 0) {
      //   console.log("Gen " + i + " avg fitness: ", tot_fit / pop_size);
      //   //console.log(population.length, " ", pop_size);
      // }
    }

    // if the best fit is 0, return an empty plan
    if (best_fit == 0) {
      let empty_plan = Array.from({ length: this.nriders }, () => []);
      console.log("Best fit is zero, returning empty plan ", empty_plan);
      best_dna = empty_plan;
    }

    // if for any driver it's better to deliver only, set its plan to deliver only
    for (let r = 0; r < this.nriders; r++) {
      if (best_d_o[r]) {
        let d_o_f = delivery_only_fits[r];
        this.riders[r].log("Seems like it's better to deliver only: ", d_o_f);
        console.log(best_d_o);
        best_dna[r] = "D";
      }
    }
    return [best_dna, best_fit];
  }

  /**
   * The function will check if the rider is carrying parcels, if so
   * it will try to generate a plan to deliver them. If no delivery zones
   * are reachable or the rider is not carrying any parcels, the function
   * will generate a plan to move to a random spawnable tile.
   * If these options are not available, the function will return a
   * reflexive move.
   *
   * @param {Rider} rider
   * @returns {Array} - The sequence of actions for the backup plan
   */
  backupPlan(rider) {
    let rew = 1;

    let path_to_closest = -1;
    let path_to_spawnable = -1;

    // if rider is carrying parcels, generate a plan to deliver them
    // otherwise generate a plan to move to a random spawnable tile
    if (rider.carrying > 0) {
      rew += rider.carrying;
      console.log("Agent is packing, going to closest delivery zone");

      let closest = this.field.getClosestDeliveryZones(
        rider.trg,
        rider.blocking_agents
      );

      if (closest.length == 0) {
        rider.log("No delivery zones reachable");
      } else {
        path_to_closest = closest[0].path;
      }
    } else {
      rider.log("No parcels on rider, generating random plan");
      path_to_spawnable = this.field.getRandomSpawnable(
        new Position(rider.trg.x, rider.trg.y),
        rider.blocking_agents
      );
    }

    let actions = [];

    if (path_to_closest != -1) {
      console.log("[BACKUP] A reachable delivery zone was found!");
      actions = Action.pathToAction(path_to_closest, ActionType.PUTDOWN, null);
    } else if (path_to_spawnable != -1) {
      console.log("[BACKUP] A reachable spawnable tile was found!");
      actions = Action.pathToAction(path_to_spawnable, ActionType.MOVE, null);
      rew = 0;
    } else {
      console.log("[BACKUP] No reachable valid plans found!");
      console.log("[BACKUP] Returning random reflexive move");
      rew = 0;
      let blocking = [];
      for (const a of rider.blocking_agents.values()) {
        blocking.push(a.x + "-" + a.y);
      }

      let movement = null;
      let target_position = null;
      for (const dir in Direction) {
        target_position = new Position(rider.trg.x, rider.trg.y).moveTo(
          Direction[dir]
        );
        console.log("trying to move ", Direction[dir], " to ", target_position);
        let target_tile = this.field.getTile(target_position);

        if (
          target_tile != -1 &&
          !this.field.isTileUnreachable(target_tile, blocking)
        ) {
          movement = Direction[dir];
          console.log("found walkable tile");
          break;
        } else {
          console.log("Tile is unreachable");
        }
      }

      let starting_action = new Action(
        rider.src,
        rider.trg,
        ActionType.MOVE,
        null
      );
      actions = [
        starting_action,
        new Action(
          new Position(rider.trg.x, rider.trg.y),
          target_position,
          ActionType.MOVE,
          null
        ),
      ];
    }

    console.log("[BRAIN] Generated BACKUP plan with rew ", rew);
    return [actions, rew];
  }

  /**
   * Generates a plan for the agents based on the genetic algorithm.
   * The genetic algorithm will return a sequence of parcels to pick up
   * for each rider. This function will call a backup plan in case the
   * genetic algorithm fails to generate a good (fit > 0) and will
   * check if it's better to deliver only.
   * Based on the generated plan, the function will generate a sequence
   * of actions for each rider.
   *
   * @returns {Array} - The sequence of actions for each rider
   */
  async createPlan() {
    try {
      let riders_graphs = [];

      // build the parcels graph for each rider with the costs and paths to move
      // from one parcel to another as well as the information (cost to reach, cost to deliver
      // and reward) of each parcel
      console.log("starting positions: ");
      for (const r of this.riders) {
          r.log("Rider at: " + r.trg.x + " " + r.trg.y);
          const [costs, paths, parc] = await this.builGraphInOut(r);
          riders_graphs.push({
              costs: costs,
              paths: paths,
              nodes: parc,
          });
      }

      // compute the delivery-only fits for each rider and generate the delivery plans
      // that will be used in case the fitness of the generated plan is lower
      // than the delivery-only plan
      let delivery_only_fits = [];
      let delivery_only_plans = [];
      for (let rid = 0; rid < this.nriders; rid++) {
        let agent = this.riders[rid];
        let closest = this.field.getClosestDeliveryZones(
          agent.trg,
          agent.blocking_agents
        );

        if (closest.length == 0) {
          delivery_only_fits.push(-Infinity);
          delivery_only_plans.push(-1);
        } else {
          let delivery_only_fit =
            agent.carrying -
            this.getStepCost(closest[0].distance, agent.player_parcels.size);

          if (delivery_only_fit <= 0) {
            delivery_only_fits.push(-Infinity);
            delivery_only_plans.push(-1);
          } else {
            delivery_only_fits.push(delivery_only_fit);
            delivery_only_plans.push(
              Action.pathToAction(closest[0].path, ActionType.PUTDOWN, null)
            );
          }
        }
      }
      console.log("delivery_only_fits: ", delivery_only_fits);

      // generate the plan using the genetic algorithm
      const [best_path, best_fit] = this.geneticTSP(
        riders_graphs,
        delivery_only_fits,
        this.pop,
        this.gen,
        0.3,
        0.5,
        0.2
      );

      //TODO:
      let parcels_path = Array.from({ length: this.nriders }, () => []);
      let all_plans = [];

      // generate the sequence of actions for each rider based on the generated plan
      for (let r = 0; r < this.nriders; r++) {
        let plan = [];

        if (best_path[r] == "D") {
          // if plan is to deliver only, assign it
          plan = delivery_only_plans[r];
        } else {
          // if no valid plan was found or fitness is 0 generate a backup plan
          if (best_path[r].length == 0 || best_fit == 0) {
            plan = this.backupPlan(this.riders[r]);

            console.log("[BRAIN] Backup plan generated");
            all_plans.push(plan[0]);
            continue;
          }

          // prepare the list of parcels to be picked up
          for (const idx of best_path[r]) {
            let par = riders_graphs[r].nodes[idx];

            parcels_path[r].push({
              pos: new Position(par.x, par.y),
              parcel: par.id,
              path_in: par.path_in,
              path_out: par.path_out,
              inc: par.in_c,
            });
          }

          let chosen_path = parcels_path[r];

          // insert current rider action as first action in case
          // the rider is not at the starting position yet
          let starting_action = new Action(
            this.riders[r].src,
            this.riders[r].trg,
            ActionType.MOVE,
            null
          );

          plan.push(starting_action);

          // insert actions for reaching the first parcel
          let actions = Action.pathToAction(
            chosen_path[0].path_in,
            ActionType.PICKUP,
            chosen_path[0].parcel
          );
          plan = plan.concat(actions);

          // insert actions for reaching the rest of the parcels
          for (let i = 0; i < best_path[r].length; i++) {
            let curridx = best_path[r][i];
            if (i + 1 < best_path[r].length) {
              let nextidx = best_path[r][i + 1];
              let semi_path = riders_graphs[r].paths[curridx][nextidx];

              actions = Action.pathToAction(
                semi_path,
                ActionType.PICKUP,
                chosen_path[i + 1].parcel
              );

              plan = plan.concat(actions);
            }
          }

          // insert actions for reaching the delivery zone and delivering the parcels
          actions = Action.pathToAction(
            chosen_path[chosen_path.length - 1].path_out,
            ActionType.PUTDOWN,
            null
          );
          plan = plan.concat(actions);
        }

        all_plans.push(plan);
      }

      // print the generated plans
      for (let r = 0; r < this.nriders; r++) {
        console.log("Plan for Rider ", this.riders[r].name);
        for (const act of all_plans[r]) {
          act.printAction();
        }
      }
      return [all_plans, best_fit];
    } catch (error) {
        console.error("Error in createPlan:", error);
        return [[], 0];
    }
  }

  /**
   * This is the function agents will call to generate a new plan.
   * A plan will be created and if it satisfies the fitness condition
   * it will be accepted, otherwise it will be rejected.
   */
  async newPlan() {
    if (this.planLock) {
        console.log("Brain is already planning...");
        return;
    }
    this.planLock = true;

    try {
        let exp_decay = 0.9;
        let start = new Date().getTime();
        const [tmp_plan, best_fit] = await this.createPlan();
        this.tot_time += new Date().getTime() - start;
        this.tot_plans += 1;
        this.plan_time_avg =
            exp_decay * this.plan_time_avg +
            (1 - exp_decay) * (this.tot_time / this.tot_plans);

        console.log("AVG plan generation ", this.tot_time / this.tot_plans, "ms");
        console.log("proposed fit ", best_fit, " current fit ", this.plan_fit);

        const MINIMUM_GAIN = 1.2;
        if (best_fit > this.plan_fit * MINIMUM_GAIN || this.plan_fit == 0) {
            this.plan_fit = best_fit;

            for (let i = 0; i < this.nriders; i++) {
                this.riders[i].plan = tmp_plan[i];
            }

            console.log("New plan accepted ✅");
        } else {
            console.log("New plan rejected ❌");
        }
    } catch (error) {
        console.error("Error in newPlan:", error);
    } finally {
        this.planLock = false;
    }
  }
  /**
   *  This is a utility function used to print the matrix of costs
   *  representing the graph of the parcels used by the genetic algorithm.
   *
   * @param {Array.Array} mat
   */
  printMat(mat) {
    let str = "\\ \t";
    for (let i = 0; i < mat.length; i++) {
      str += i + "\t";
    }
    str += "\n";
    for (const row of mat) {
      str += mat.indexOf(row) + "\t";
      for (const cell of row) {
        let val = cell;
        if (cell > 9000) {
          val = "∞";
        }
        str += val + "\t";
      }
      str += "\n";
    }
    console.log(str);
  }
}

================
File: master_rider.js
================
import { Position } from "./data/position.js";
import { Action, ActionType } from "./data/action.js";
import { Genetic } from "./master_geneticBrain.js";
import { DeliverooApi } from "@unitn-asa/deliveroo-js-client";

/**
 * A rider is a player in the game. This class contains
 * all the information about the player's state and actions.
 *
 * @param {string} uname The username of the rider
 *
 * @property {number} carrying amount of points the rider is carrying
 * @property {Array} plan list of actions the rider will take
 * @property {number} no_delivery amount of turns since the rider last delivered
 * @property {Object} config configuration of the game
 * @property {string} uname username of the rider
 * @property {boolean} player_init whether the player has been initialized
 * @property {boolean} putting_down whether the player is putting down a parcel
 * @property {number} plan_cooldown turns until the player can plan again
 * @property {Map} player_parcels parcels the player is carrying
 * @property {Map} blocking_agents agents that are blocking the player
 * @property {Genetic} brain the player's brain
 * @property {DeliverooApi} client the player's client
 * @property {number} id the player's id
 * @property {string} name the player's name
 * @property {number} score the player's score
 * @property {Position} position the player's position
 * @property {Position} src the player's action source position
 * @property {Position} trg the player's action target position
 * @property {Action} nextAction the player's next action
 */
export class Rider {
  constructor(uname) {
    this.uname = uname;

    // Game state
    this.carrying = 0;
    this.plan = [];
    this.no_delivery = 0;
    this.config = {};
    this.player_init = false;
    this.putting_down = false;
    this.plan_cooldown = 0;
    this.player_parcels = new Map();
    this.blocking_agents = new Map();

    //this.brain = new Genetic(this.blocking_agents);
    this.client = new DeliverooApi(
      "http://localhost:8080/?name=" + this.uname,
      ""
    );

    console.log("Rider created");
  }

  /**
   *
   * @param {string} id  id of the rider
   * @param {string} name  name of the rider
   * @param {{x:number, y:number}} position  starting position of the rider
   * @param {Genetic} brain  brain of the rider
   */
  init(id, name, position, brain) {
    this.id = id;
    this.name = name;
    this.brain = brain;

    // Movement state
    this.position = position;
    this.src = new Position(position.x, position.y);
    this.trg = new Position(position.x, position.y);
    this.nextAction = null;
  }

  /**
   * @param {Map} config configuration of the game
   */
  setConfig(config) {
    this.config = config;
    console.log("Config received: ", this.config);
  }

  /**
   * @param {number} x x coordinate of the player
   * @param {number} y y coordinate of the player
   */
  updatePosition(x, y) {
    this.position.x = x;
    this.position.y = y;
  }

  /**
   * Checks whether the target of the current action
   * is blocked by another agent
   *
   * @returns {boolean} whether the target is blocked
   */
  isPathBlocked() {
    let blocked = false;
    for (const a of this.blocking_agents.values()) {
      if (a.x == this.trg.x && a.y == this.trg.y) {
        blocked = true;
        break;
      }
    }
    return blocked;
  }

  /**
   * Function to log messages with the player's name
   *
   * @param  {...any} args arguments to log
   */
  log(...args) {
    console.log("[", this.name, "] ", ...args);
  }
}

================
File: multi_dashboard.html
================
<!-- index.html -->
<link href="/path/to/dashboard.css" />
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dashboard</title>
  </head>
  <body>
    <h1>GlovoJS</h1>

    <div id="mapdiv">
      <table
        id="myTable"
        class="table table-borderless table-striped table-earning"
      >
        <tbody id="mapTable"></tbody>
      </table>
    </div>
    <div id="info"></div>
    <div id="carrying"></div>
    <div id="carrying_points"></div>

    <div id="carry_div"></div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const socket = io();

      socket.on("update", (data) => {
        document.getElementById("updates").innerText = JSON.stringify(data);
      });

      socket.on("map", (data) => {
        w = data["map_size"][0];
        h = data["map_size"][1];
        tiles = data["tiles"];
        parcels = data["parc"];
        riders = data["riders"];

        let pathcolors = [
          "blue",
          "violet",
          "grey",
          "darkgreen",
          "black",
          "white",
        ];
        let ridercolor = [
          "lightblue",
          "pink",
          "lightgrey",
          "MediumSeaGreen",
          "darkgrey",
          "white",
        ];
        //   document.getElementById('info').innerHTML = "<div><h2>"+plan_target+"</h2><div>";

        //   document.getElementById('carrying').innerHTML = "<div>"+rider_parcels.map((el, idx) => {
        //   return (el.key);
        //  });"<div>";

        //  document.getElementById('carrying_points').innerHTML =  "<div><h2>"+carrying+" points </h2><div>";

        const table = document.getElementById("mapTable");
        table.innerHTML = "";

        // console.log(data["parc"]);

        for (let i = 0; i < h; i++) {
          let y = h - i - 1;
          let row = table.insertRow();

          for (let j = 0; j < w; j++) {
            let x = j;

            let tile = row.insertCell();

            tile_html = "<div style='display: table;width:100%;height:100%;'>";
            tile.style.width = "20px";
            tile.style.height = "20px";
            let color = "black";
            switch (tiles[y][j]["type"]) {
              case "W":
                color = "green";
                break;
              case "D":
                color = "red";
                break;
            }

            cell_id = x + "-" + y;
            //console.log(str);
            let pardone = false;
            let to_pickup = false;
            for (let rid = 0; rid < riders.length; rid++) {
              plan_move = riders[rid].plan[0];
              plan_pickup = riders[rid].plan[1];
              plan_drop = riders[rid].plan[2];
              blk_agents = riders[rid].blk_agents;

              if (plan_move.includes(cell_id)) {
                pathcolor = pathcolors[rid];
                tile_html +=
                  "<div style='width:80%;height:80%;background-color:" +
                  pathcolor +
                  ";'></div>";
              }

              if (!pardone) {
                for (p of parcels) {
                  if (p.x == x && p.y == y) {
                    color = "yellow";
                    tile_html +=
                      "<div style='position: absolute;'><b>" +
                      p.reward +
                      "</b></div>";
                  }
                }
                pardone = true;
              }

              if (plan_pickup.includes(cell_id)) {
                to_pickup = true;
                //color = "GreenYellow";
              } else if (plan_drop.includes(cell_id)) {
                color = "orange";
              }
            }
            if (to_pickup) {
              color = "GreenYellow";
            }
            for (let rid = 0; rid < riders.length; rid++) {
              blk_agents = riders[rid].blk_agents;

              if (blk_agents.includes(cell_id)) {
                color = "purple";
              }
            }
            tile_html += "</div>";

            tile.innerHTML = tile_html;
            tile.style.backgroundColor = color;
          }
          let tile = row.insertCell();
          tile.innerHTML = "<div>" + y + "</div>";
        }
        let row = table.insertRow();
        for (let j = 0; j < w; j++) {
          let tile = row.insertCell();
          tile.innerHTML = "<div>" + j + "</div>";
        }

        for (let rid = 0; rid < riders.length; rid++) {
          rider = riders[rid];

          table.rows[Math.round(h - rider.y) - 1].cells[
            Math.round(rider.x)
          ].innerHTML = "<div ></div>";
          table.rows[Math.round(h - rider.y) - 1].cells[
            Math.round(rider.x)
          ].style.backgroundColor = ridercolor[rid];
        }

        // TABLE OF CARRIED PARCELS

        const carry_div = document.getElementById("carry_div");
        carry_div_html = "";

        for (let rid = 0; rid < riders.length; rid++) {
          carry_div_html +=
            '<table style="border: 1px solid black;display: inline-block;" id="my_carry_table">';
          carry_div_html += '<tbody id="carry_table' + rid + '"></tbody>';
          carry_div_html += "</table>";
        }
        carry_div.innerHTML = carry_div_html;
        console.log(carry_div.innerHTML);

        for (let rid = 0; rid < riders.length; rid++) {
          let carry_table = document.getElementById("carry_table" + rid);
          carry_table.innerHTML = "";
          rider_parc = riders[rid].parcels;
          // console.log("rp: ", rider_parc);
          for (let i = 0; i < rider_parc.length; i++) {
            let row = carry_table.insertRow();

            row.style.border = "1px solid #000";

            let rider_cell = row.insertCell();
            let key_cell = row.insertCell();
            let rew_cell = row.insertCell();

            rider_cell.style.border = "1px solid #000";
            rider_cell.style.backgroundColor = ridercolor[rid];
            key_cell.style.border = "1px solid #000";
            rew_cell.style.border = "1px solid #000";

            parcel = rider_parc[i];

            rider_cell.innerHTML = "<div><b>Rider " + rid + "</b></div>";
            key_cell.innerHTML = "<div><b>" + parcel.key + "</b></div>";
            rew_cell.innerHTML = "<div><b>" + parcel.reward + "</b></div>";
          }
        }
      });
    </script>
  </body>
</html>

================
File: package.json
================
{
  "name": "asa_glovojs",
  "version": "1.0.0",
  "description": "helo",
  "type": "module",
  "main": "index.js",
  "module": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node master_agent.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@unitn-asa/deliveroo-js-client": "^0.0.37",
    "@unitn-asa/pddl-client": "^0.0.37",
    "express": "^4.19.2",
    "node-fetch": "^3.3.0",
    "socket.io": "^4.7.5",
    "socket.io-client": "^4.6.0"
  }
}

================
File: README.md
================
# ASA_Glovojs

## NOTES

- high populations seem to work better in more open maps whereas low populations work better in more closed maps. Might be due to the higher chance of replanning in busier maps that penalize the high pupulation agent since planning is more costly and it impacts the speed of the agent. While the plans might be better the speed of the "dumber" agents allows them to steal parcels and deliver them faster.

## TODO

- [x] Define interfaces
- [x] Implement actions data structure
- [x] Implement actions actuation
- [x] Implement dashboard
- [x] Implement planner
- [x] Improve reasoning to pick up multiple parcels instead of delivering asap
- [x] Stop going after parcels that have already been delivered
- [x] Anytime the agent steps on a parcel, pick it up
- [x] Anytime the agent steps on a delivery zone, deliver
- [x] (kinda) Prevent moving to unreachable tiles
- [x] Contain all planning inside the brain
- [x] Make sure planner doesnt miss new or previously discovered parcels
- [x] Planner must consider other agent's positions
- [x] Planner must make sure agent can get unstuck
- [x] Make sure planner doesnt forget he's carrying parcels when replanning
- [x] Double check for closest delivery point

- [x] Make sure agent knows how much (and how many parcels) he can carry when replanning
- [x] Penalize overly long paths
- [x] make sure agent forgets parcels left in memory when the tile comes back in view and the parcel is gone

- [x] Make sure agent doesnt crash when NO plan is found (og no parcels, no delivery zones, no reachable tiles)

- [x] reimplement agent blocking logic

- [x] fix crossover for multiple agents
- [x] make sure player_parcels are handled correctly in the planner
- [x] make sure parcels are correctly memorized
- [x] fix bfs crashing when position is not round
- [x] penalize too many plan changes
- [x] check if carried parcels are correcly evaluated when replanning
- [x] rework parcels clock
- [x] figure out why agent crashes when 2-action long backup plan is created and after consuming action

- [x] make sure it's possible to generate a plan with delivery only in case one agent has parcels
- [x] fix the stuff about fitness in delivery only
- [x] rethink logic when it's time to replan (due to delivery or plan end)

- [x] fix dashboard now highlighting all the parcels to be picked up
- [x] fix plans swapping between agents (might be an indexing issue)
- [x] make sure a valid plan is created if one agent has no reachable parcels
- [x] make sure in geneticTSP when one rider has no nodes (so zero genes) it doesn't happen that a random plan is generated for ALL riders.
- [?] fix agent not seeing (?) parcel when in the same cell (might be due to delayed replanning OR too short bfs)

- [ ] fix order of parcels in plan generation
- [x] add caching system for bfs
- [ ] make sure cache doesn't get too big
- [ ] penalize riders that don't deliver for too long (exp in case of non-decaying parcels)
- [ ] add replanning when parcels are stolen
- [x] clean code
- [x] search&destroy legacy variables
- [x] reimplement parcel decay in fitness
- [x] is the dummy_parcel in builGraphInOut even needed? (might be a leftover from the old implementation)
- [x] make sure chances are computed correctly in rouletteWheel, in particular in case of negative fit (for the moment I set a lower bound for fitness as -Infinity screws with the probabilities and removed the rounding of the chances) THIS MUST BE VERIFIED
- [x] dynamically change STEP_COST and penalities based on the config
- [ ] exponential decay for metrics might not be that beneficial
- [x] reimplement parcels clock

================
File: server.js
================
// server.js
import { Server } from "socket.io";
import http from "http";
import express from "express";
import path from "path";

export class MyServer {
  constructor(port) {
    this.app = express();
    this.server = http.createServer(this.app);
    this.io = new Server(this.server);
    console.log("Server constructor: ", port);
    this.port = port;
    this.start();
    this.serveDashboard();
  }

  serveDashboard() {
    this.app.get("/", (req, res) => {
      const dashboardPath = new URL("./multi_dashboard.html", import.meta.url)
        .pathname;
      const decodedPath = decodeURIComponent(dashboardPath);
      const normalizedPath = path.normalize(decodedPath);
      console.log(normalizedPath);
      res.sendFile(normalizedPath);
    });
  }

  start() {
    // let rando_port = Math.floor(Math.random() * 10000) + 1;
    // rando_port = 3000;
    this.server.listen(this.port, () => {
      console.log("Dashboard server running on http://localhost:" + this.port);
    });
  }

  emitMessage(event, data) {
    this.io.emit(event, data);
  }
}

// export default new MyServer();

================
File: utils.js
================
/**
 * Sorts an array of objects by a key
 *
 * @param {Array} array
 * @param {string} key
 * @returns {Array}
 */
export function sortByKey(array, key) {
  return array.sort(function (a, b) {
    var x = a[key];
    var y = b[key];
    return x < y ? -1 : x > y ? 1 : 0;
  });
}

/**
 * Returns the Manhattan distance between two points,
 * a and b can be either Position or {x:number, y:number}
 *
 * @param {Position} a
 * @param {Position} b
 *
 * @returns {number}
 */
export function manhattanDistance(a, b) {
  return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

/**
 * Checks whether a a position is fully aligned with the grid
 *
 * @param {Position} pos
 */
export function hasCompletedMovement(pos) {
  return pos.x % 1 === 0.0 && pos.y % 1 === 0.0;
}
